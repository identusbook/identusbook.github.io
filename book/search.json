[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Mastering Identus: A Developer Handbook",
    "section": "",
    "text": "Welcome\nWelcome to the book!",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "copyright.html",
    "href": "copyright.html",
    "title": "1  Copyright",
    "section": "",
    "text": "IdentusBook.com\nCopyright @2024 Jon Bauer and Roberto Carvajal\nAll rights reserved\nPlease see our License for more information about fair use.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Copyright</span>"
    ]
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "2  License",
    "section": "",
    "text": "2.1 Book Content:\nThe content of the book (text, printed code, and images) are licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0\nThe intent here is to allow anyone to use or excerpt from the book as long as they credit the source. In general we are very open to having our work shared non-commercially. We are copyrighting this book to protect the ability to version and revise the work officially, and to keep open the door for a print version if the opportunity arises and/or makes sense.\nIf you’d like to commercially reproduce contents from this book, please contact us.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>License</span>"
    ]
  },
  {
    "objectID": "license.html#applications",
    "href": "license.html#applications",
    "title": "2  License",
    "section": "2.2 Applications:",
    "text": "2.2 Applications:\nThe example code that accompanies this book is licensed under a MIT License\nThis allows anyone to freely take, modify, or redistribute the code as long as they also assign the MIT license to it.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>License</span>"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "4  Preface",
    "section": "",
    "text": "Explains who the authors are and why we were motivated to write this book.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "section1/introduction.html",
    "href": "section1/introduction.html",
    "title": "5  Introduction",
    "section": "",
    "text": "This is a developer-centric book about creating and launching Self-Sovereign applications with Identus. We aim to show the reader how to configure, build and deploy a complex idea from scratch.\nThis is not a book about Self-Sovereign Identity. There are already great resources available on that topic. If you’re new to the idea of SSI or Identus, we reccomend the exellent resources listed below as a pre-requisite to this text.\n\nSelf-Sovereign Identity by Alex Preukschat, Drummond Reed, et al. This is the definitive book on SSI and it’s ecosystem of topics.\nAtala PRISM Documentation\n\nIt should be noted that Identus is still new and at the time of writing this book, there are very few best practices, in fact, very little practices at all. A handfull of advanturous developers have been building on the platform and sharing their experiences, and we hope to share our own learnings in hopes of magnifying that knowledge and helping developers skip the common pitfalls and bring their ideas to market.\nWe hope this text will be accessible to anyone who’s curious about what’s\nWe hope that newcomers will be able to use this text to skip common pitfalls and misunderstandings, and bring their ideas to market faster.\nWe’re glad you could join us :)",
    "crumbs": [
      "Section I",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "section1/ssi-basics.html",
    "href": "section1/ssi-basics.html",
    "title": "6  SSI Basics",
    "section": "",
    "text": "[SSI Roles/Conceptual Diagram (Triangle of Trust)]\nIssuer:\nThe entity that issues a Verifiable Credential to a Holder. This could be a bank, government agency or anyone that accepts responsibility for making credentials. For example a governmental agency can issue a passport to a citizen, or a gym can issue a membership to a member. The type of agency is not important, only that they issue a credential. This role accepts responsibility for having issued that credential and should look to establish trust and reputation with Holders and Verifiers. The Issuer’s DID will be listed in the Issuer (iss:) field of a Verifiable Credential and can be inspected by anyone wishing to know the origin of the credential.\nHolder:\nA Holder is simply any person or wallet that holds a Verifiable Credential. Verifiable Credentials can represent anything, a gym membership, an accomplishment like a University degree, or a permission set, such as a login or authentication role.\nVerifier:\nA Verifier is any person or wallet that performs a verification on a Verifiable Credential or any of it’s referenced entities. A Verifier might perform a check on cryptographic elements of a VC, or make sure that the Issuer DID belongs to the expected entity. Verifiers usually only care to double check that the Verifiable Credential is legitimate and that the included claims meet their expectations, for example when a bartender checks the age of a patron before serving them alcohol.\nTrust Registry:\nWhen Verifiers need to know who a DID belongs to, there needs to be a way to look up that information. A Trust Registry is a mapping between DIDs and the entities they represent. You can think of this like a phone book for DIDs. Trust Registries need to be trusted themselves, and can be as broad or as specific as they need to be. For example, an Real Estate specific Trust Registry that lists real estate agents can be a way to validate that a particular agent is an accepted member of that industry.",
    "crumbs": [
      "Section I",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>SSI Basics</span>"
    ]
  },
  {
    "objectID": "section1/identus-concepts.html",
    "href": "section1/identus-concepts.html",
    "title": "7  Identus Concepts",
    "section": "",
    "text": "[Identus Application Architecture Diagram]\nIdentus is made up of several open source components. Each could be used or forked separately but they are designed to work well together.\nPRISM Node:\nPRISM Node implements the did:prism methods and is an interface to multiple VDR (Verifiable Data Registries). The node can resolve PRISM DIDs and write transactions to a blockchain or database. PRISM Node is expected to be online at all times.\nCloud Agent:\nWritten in Scala, the Cloud Agent runs on a server and communicates with clients and peers via a REST API. It is a critical component of an Identus application, able to manage identity wallets and their associated operations, as well as issue Verifiable Credentials. The Cloud Agent is expected to be online at all times.\nEdge Agent:\nEdge Agents give agent capabilities to clients like Websites and mobile apps. They can can never be assumed to be online at any given time, and therefore rely on sending and receiving all communications through an online proxy, the Mediator.\nDIDComm:\nDIDComm is a private, secure, and interoperable protocol for communication between decentralized identities. Identus supports DIDCommV2 and allows peers to pass messages between each other, proxied by the Mediator. Messages contain a to: and from: DID\nMediator:\nMediators act as middlemen between Peer DIDs. In order for any agent to send a message to any other agent, it must know the to and from DIDs of each message. The sender and recipient together make up a cryptographic connection called a DIDPair. Mediators maintain queues of messages for each DIDPair. If an Edge Agent is offline, the Mediator will hold incoming messages for them until the agent is back online and able to receive them. Mediators can deliver messages when polled, or push via Websockets. Mediators are expected to be online at all times and be highly available.\nSince instantiation of Identus Edge Agents requires a Mediator, there are several publicly available Mediator services which make development simple.\n\nPRISM Mediator\nRootsID Mediator\nBlocktrust Mediator\n\nWhile extremely helpful during development, these are not recommended for production Identus deployments as they have no uptime guarantee and will not scale past a small number of concurrent users. We will discuss how to run your own Mediator in Chapter 20\nBuilding Blocks:\nIdentus separates the handling of important SSI operations into separate, focused libraries.\nApollo: Apollo is a cryptographic primitives toolbox, which Identus uses to ensure data integrity, authenticity, and confidentiality.\nCastor: Castor enables creation, management, and resolution of DIDs.\nPollux: Pollux handles all Verifiable Credential operations.\nMercury: Mercury is an interface to the DIDCommV2 protocol, allowing the sending and receiving of messages between DIDs.\nMore info on each of the Building Blocks can be found in the Docs",
    "crumbs": [
      "Section I",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Identus Concepts</span>"
    ]
  },
  {
    "objectID": "section2/installation-local.html",
    "href": "section2/installation-local.html",
    "title": "8  Installation - Local Environment",
    "section": "",
    "text": "8.1 Introduction\nHyperledger Identus, previously known as Atala PRISM, is distributed across various repositories. These repositories group together different building blocks to provide the necessary functionality for fulfilling each of the essential roles in Self-Sovereign Identity (SSI), as introduced in Identus Concepts and SSI Basics. Throughout this book, we will detail the setup of each component.\nThe initial component to set up is our Cloud Agent. This agent is responsible for creating and publishing DID Documents into a Verifiable Data Registry (VDR), issuing Verifiable Credentials, and, depending on the configuration, even providing Identity Wallets to multiple users through a multi-tenancy setup. For now, our focus will be on setting up the Cloud Agent to run locally in development mode, supporting only a single tenant. This step is crucial for learning the basics and getting started. As we progress and build our example application, we will deploy the Cloud Agent in development mode first, then set it up to connect to Cardano testnet as our VDR on pre-production mode and, finally, in production mode with multi-tenancy support connected to Cardano mainnet. This will be a gradual process as we need to familiarize on each stage of the Cloud Agent.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Installation - Local Environment</span>"
    ]
  },
  {
    "objectID": "section2/installation-local.html#identus-releases-overview",
    "href": "section2/installation-local.html#identus-releases-overview",
    "title": "8  Installation - Local Environment",
    "section": "8.2 Identus Releases Overview",
    "text": "8.2 Identus Releases Overview\nIdentus is built upon multiple interdependent building blocks, including the Cloud Agent, Wallet SDK, Mediator, and Apollo Crypto Library. To ensure compatibility among these components, it is crucial to identify the correct building block versions that are compatible between them. For this purpose, a dedicated repository named atala-releases is available. This repository provides comprehensive documentation and a compatibility table for each Identus Release. We will be using Identus v2.12 as our selected release because it is the latest at the time of writing (May 2024).",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Installation - Local Environment</span>"
    ]
  },
  {
    "objectID": "section2/installation-local.html#pre-requisites",
    "href": "section2/installation-local.html#pre-requisites",
    "title": "8  Installation - Local Environment",
    "section": "8.3 Pre-requisites",
    "text": "8.3 Pre-requisites\n\n8.3.1 Git\nGitHub is currently the primary platform for hosting repositories. As of this writing, projects are transitioning from Atala PRISM’s original repositories to Hyperledger ones, with the Cloud Agent being the first to migrate. For more details, you can read the press release here.\nIf you’re using a UNIX-based system (such as OS X or Linux), you likely already have git installed. If not, you can download the installer from Git downloads. Additionally, various GUI clients are available for those who prefer a graphical interface.\nTo clone the Cloud Agent repository, first go to the Releases page and identify the tagged release corresponding to the Identus release you are targeting (e.g. cloud-agent-v1.33.0 is part of Identus v2.12 release), then clone the repository with this command:\ngit clone --depth 1 --branch cloud-agent-v1.33.0 https://github.com/hyperledger/identus-cloud-agent\n\n\n\n\n\n\nNote\n\n\n\nUsing --depth 1 will skip the history of changes in the repository up until the point of the tag, this is optional.\n\n\n\n\n8.3.2 Docker\nThe Cloud Agent and Mediator are distributed as Docker containers, which is the recommended method for starting and stopping the various components required to run the cloud infrastructure.\nTo begin, install Docker Desktop, which provides everything you need to get started.\n\n\n8.3.3 WSL\nFor Windows users, please refer to How to install Linux on Windows with WSL.\n\n\n\n\n\n\nNote\n\n\n\nWindows is the least tested environment, the community has already found some issues and workarounds on how to get the Cloud Agent working. We will try to always include instructions regarding this use case.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Installation - Local Environment</span>"
    ]
  },
  {
    "objectID": "section2/installation-local.html#before-we-run-the-agent",
    "href": "section2/installation-local.html#before-we-run-the-agent",
    "title": "8  Installation - Local Environment",
    "section": "8.4 Before We Run The Agent",
    "text": "8.4 Before We Run The Agent\nOnce you have cloned the identus-cloud-agent repository and Docker is up and running you can jump right ahead and run the agent, but before we do that if you are not yet familiar with the community projects or the structure of the agent itself, we recommend you to spend a little time exploring the following information, this is optional and you can skip it.\n\n8.4.1 Atala Community Projects\nThere is a growing list of community repositories that aim to provide some extra functionality, mostly maintained by official developers and community members on their spare time. At present time there are three Atala Community Projects:\n\nPluto Encrypted: Implementation of Pluto storage engine with encryption support.\nEdge Agent SDK Demos: Browser and Node versions of Edge Agent SDK integrated with Pluto Encrypted.\nIdentus Test: Shell script helper that will checkout a particular Identus release and compatible components.\n\n\n\n8.4.2 Exploring The Repository\nThere are two fundamental directories inside the repository if you are an end user.\n\ndocs Where all the latest technical documentation will be available, this includes the Architecture Decision Records (ADR), general insights, guides to deploy, examples and tutorials about how to handle VC Schemas, Connections, secrets, etc. We will do our best to explain in detail all this procedures as we build our example app.\ninfrastructure This directory holds the agent’s Docker file and related scripts to run the agent in different modes such as dev, local or multi. The way to change the agent setup is by customizing environmental variables trough the Docker file, so we really advise you to get familiar with the shared directory content, because that’s the base for every other mode, in essence, every mode is a customization of the shared Docker file.\n\nOur first mode to explore and the simplest one should be local mode, which by default will run a single agent as a single-tenant, meaning that this instance will control only a single Identity Wallet that will be automatically created and seeded upon the first start of the agent.\nThe multi mode essentially runs 3 different local agents but each is assigned a particular role such as issuer, holder and verifier. This is useful in order try test more complex interactions between independent actors.\nFinally the dev mode is meant to be used for development and provides an easy way to modify the Cloud Agent source code, it does not rely on the pre-built Docker images that the local mode fetches and run. We will not use this mode at all trough the book but feel free to explore this option if you would like to make contributions to the Cloud Agent in the future.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Installation - Local Environment</span>"
    ]
  },
  {
    "objectID": "section2/installation-local.html#running-the-cloud-agent",
    "href": "section2/installation-local.html#running-the-cloud-agent",
    "title": "8  Installation - Local Environment",
    "section": "8.5 Running The Cloud Agent",
    "text": "8.5 Running The Cloud Agent\n\n8.5.1 Environment Variables\nInside infrastructure/local directory, you will find three important files, run.shand stop.sh scripts and the .env file.\nOur local environment file should look like this\nAGENT_VERSION=1.33.0\nPRISM_NODE_VERSION=2.2.1\nVAULT_DEV_ROOT_TOKEN_ID=root\nThis will tell Docker which versions of the Cloud Agent and PRISM Node to run, plus a default value for the VAULT_DEV_ROOT_TOKEN_ID, this value corresponds to the HashiCorp Token ID. HashiCorp is a secrets storage engine and it will become relevant later on when we need to prepare the agent to run in prepod and production modes, for now the local mode will ignore this value because by default it will use a local postgres database for it’s secret storage engine.\nThe run.sh script options:\n./run.sh --help\nRun an instance of the ATALA bulding-block stack locally\n\nSyntax: run.sh [-n/--name NAME|-p/--port PORT|-b/--background|-e/--env|-w/--wait|--network|-h/--help]\noptions:\n-n/--name              Name of this instance - defaults to dev.\n-p/--port              Port to run this instance on - defaults to 80.\n-b/--background        Run in docker-compose daemon mode in the background.\n-e/--env               Provide your own .env file with versions.\n-w/--wait              Wait until all containers are healthy (only in the background).\n--network              Specify a docker network to run containers on.\n--webhook              Specify webhook URL for agent events\n--webhook-api-key      Specify api key to secure webhook if required\n--debug                Run additional services for debug using docker-compose debug profile.\n-h/--help              Print this help text.\nFor our first interaction with the agent all we have to do is to call the run script. If you have any conflicts with the port 80 already in use or you don’t want that as the default, you can pass --port 8080 or any other available port that you would like to use.\nSo, from the root of the repository you can run:\n./infrastructure/local/run.sh\nThis will take a while the first time as Docker will fetch the required container images and get them running. To check the status of the Cloud Agent you can use curl or open a browser window at same endpoint URL (make sure to specify a custom port if you changed it in the previous step, e.g. use http://localhost:8080):\ncurl http://localhost/cloud-agent/_system/health\n{\"version\":\"1.33.0\"}\nThe version should match the version of the Cloud Agent defined in the .envfile.\nTo stop the agent, you can press Control + C or run:\n./infrastructure/local/stop.sh\nCongratulations! you have successfully setup the agent in local mode. Next we will explore our Docker file in detail and interact with our agent using the REST API.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Installation - Local Environment</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html",
    "href": "section2/agent-rest-api.html",
    "title": "9  Agent REST API",
    "section": "",
    "text": "9.1 The Cloud Agent API\nThe only way to interact with our newly created Cloud Agent is trough the REST API, this means any action of the Cloud Agent such as establishing connections, creating Credential Schemas, issuing Verifiable Credentials, etc. will be triggered trough the agent API endpoints.\nIt is crucial to understand that the API is essentially an abstraction of the agent’s Identity Wallet. In our initial setup our agent is running on single-tenant mode, therefor it is managing a single default wallet which is assigned the following Entity ID (UUID) 00000000-0000-0000-0000-000000000000. You can confirm this by running the following command:\nLater on the book, once we start building our example app, we will setup the agent in multi-tenant mode, meaning that a single agent instance will be capable of managing multiple wallets, we refer to those wallets as custodian wallets. This more advanced setup is useful when your users would want to delegate their Identity Wallet custody to a service instead of managing the wallet themselves.\nBesides the _system/health endpoint we used earlier to confirm the agent version, there is one more endpoint used to debug runtime metrics:\nThis will be useful when debugging a memory or performance issue or when developing.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html#the-cloud-agent-api",
    "href": "section2/agent-rest-api.html#the-cloud-agent-api",
    "title": "9  Agent REST API",
    "section": "",
    "text": "docker logs local-cloud-agent-1 | grep \"default\"\n\n\n... Initializing default wallet.\n... Default wallet seed is not provided. New seed will be generated.\n... Entity created: Entity(00000000-0000-0000-0000-000000000000,default,00000000-0000-0000-0000-000000000000,1970-01-01T00:00:00Z,1970-01-01T00:00:00Z)\n\n\ncurl http://localhost/cloud-agent/_system/metrics\n# HELP jvm_memory_bytes_used  \n# TYPE jvm_memory_bytes_used gauge\njvm_memory_bytes_used{area=\"heap\",} 1.07522616E8\njvm_memory_bytes_used{area=\"nonheap\",} 1.74044936E8\n...",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html#openapi-specification",
    "href": "section2/agent-rest-api.html#openapi-specification",
    "title": "9  Agent REST API",
    "section": "9.2 OpenAPI Specification",
    "text": "9.2 OpenAPI Specification\nThe OpenAPI Specification (OAS) defines a standard, language-agnostic interface to HTTP APIs. The Cloud Agent API documentation can be found at https://docs.atalaprism.io/agent-api/ and besides being very detailed and always updated to the latest, it also comes with the OAS spec yaml file that will allow us to setup Postman to easily test our API or use the same OAS standard to auto generate code for client libraries on different language stacks. We will not attempt to repeat this API documentation in the book, rather lets focus on complement the existing documentation and explain with more detail how everything works.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html#apisix-gateway",
    "href": "section2/agent-rest-api.html#apisix-gateway",
    "title": "9  Agent REST API",
    "section": "9.3 APISIX Gateway",
    "text": "9.3 APISIX Gateway\nAPISIX is in charge of proxying different services inside the container, exposing three routes trough the port you specified to the run.sh script (remember it runs on port 80 by default).\n\nhttp://localhost/cloud-agent/ This will be the Cloud Agent API.\nhttp://localhost/apidocs/ Swagger UI interface test the API.\nhttp://localhost/didcomm/ Our public DIDCOMM endpoint, this is our communication channel and it’s how we send end to end encrypted messages to another peer trough a mediator. We will take a deep dive into DIDCOMM later in the book.\n\nAPISIX by default will just expose this services but trough plugins it can be setup as Ingress controller, load balancer, authentication and much more. You can read the APISIX documentation to learn more.\n\n\n\n\n\n\nWarning\n\n\n\nThis is where CORS (Cross-Origin Resource Sharing) is setup, be default it will allow any origin, here you can restrict which domains should be allowed to connect to this endpoints. We will revisit this on our customization guide.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html#swagger-ui",
    "href": "section2/agent-rest-api.html#swagger-ui",
    "title": "9  Agent REST API",
    "section": "9.4 Swagger UI",
    "text": "9.4 Swagger UI\nSwagger UI it’s a visualization and interactive tool to explore an API. It’s automatically generated from your OpenAPI (formerly known as Swagger) Specification and it’s often used to support the API documentation.\nOur Cloud Agent Docker file includes a container for Swagger UI that is exposed trough APISIX as explained earlier. This means you can use this tool right away after the agent is running.\nTo use it, just open http://localhost/apidocs/ in your browser and from the server list select:\n\nhttp://localhost/cloud-agent - The local instance of the Cloud Agent behind the APISIX proxy.\n\nThen, click the Authorize button and a small modal window will popup, in there you need to define an apikey, even if by default you haven’t defined one, this means you can put any value in here, of course later in the book when we set an actual apikey you will need to use it here, for now just use test as value and it should be fine.\nAfter authorizing, the modal should look like this:\n\n\n\nSwagger UI Apikey Modal\n\n\nYou can close that modal window and try your first request, click to expand the GET /connections endpoint and click Try it out button, that will enable the text inputs for any available parameters, for now, all three parameters should be blank (offet, limit, thid).\nFinally, just click the Execute button to actually perform the request. This should return something like this:\n{ \"contents\": [], \"kind\": \"ConnectionsPage\", \"self\": \"\", \"pageOf\": \"\" }\nCongratulations! you have connected to the API and asked for a list of connections, right now there are no connections so the empty array you get back is correct.\n\n\n\n\n\n\nNote\n\n\n\nYou can use Swagger UI to copy curl commands that you can paste in your terminal, this will run exactly the same API request. For example:\ncurl -X 'GET' \\\n  'http://localhost/cloud-agent/connections' \\\n  -H 'accept: application/json' \\\n  -H 'apikey: test'\n{\"contents\":[],\"kind\":\"ConnectionsPage\",\"self\":\"\",\"pageOf\":\"\"}",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html#postman",
    "href": "section2/agent-rest-api.html#postman",
    "title": "9  Agent REST API",
    "section": "9.5 Postman",
    "text": "9.5 Postman\nPostmanis perhaps the most popular API tool among developers, it allow us to easily interact and debug API endpoints but has many killer feature like enabling teams to share and work together on the same API, run automated tests, automatically renew tokens, keeps the state of your interactions with the API, copy code snippets to make API calls over many languages, etc. So it’s really a better overall option versus the Swagger UI interface or just directly using curl.\nThe big time saver for us is that because it supports OAS, we can easily import the whole API definition. So, let’s try it:\n\nIf you don’t already have it, first you should Download Postman and Sign Up for a free account.\nHead to the API docs and click the Download button, or copy this direct link https://docs.atalaprism.io/redocusaurus/plugin-redoc-0.yaml\nInside Postman, go to File -&gt; Import and either drag & drop your yaml file if you downloaded it or paste the URL in the box, this will auto advance to the next step.\nOn the “How to import” step select “OpenAPI 3.0 with a Postman Collection” and click import.\n\nIf everything goes correctly, you should see “Identus Cloud Agent API Reference” in your collections.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html#tutorials",
    "href": "section2/agent-rest-api.html#tutorials",
    "title": "9  Agent REST API",
    "section": "9.6 Tutorials",
    "text": "9.6 Tutorials\nThe official documentation contains a tutorials section with detailed walkthroughs for each of the most important interactions like connecting to another peer, managing DIDs, managing VC Schemas, issuing a VC, etc. We highly encourage you to follow those and get familiar with the API, this will come in very handy very soon when we start building our own example app.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section3/project-overview.html",
    "href": "section3/project-overview.html",
    "title": "10  Project Overview",
    "section": "",
    "text": "This is project overview of the example app, which can issue and verify educational credentials.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Project Overview</span>"
    ]
  },
  {
    "objectID": "section3/wallets.html",
    "href": "section3/wallets.html",
    "title": "11  Wallets",
    "section": "",
    "text": "A deep dive on what an Identus Identity wallet is and represents. We will discuss seed phrases and how they work.\nWe will talk about creating and recovering Identus wallets.\nTips for using:\n\nPluto Encrypted\nKeycloak for OAuth / OpenIDConnect",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Wallets</span>"
    ]
  },
  {
    "objectID": "section3/dids.html",
    "href": "section3/dids.html",
    "title": "12  DIDs",
    "section": "",
    "text": "We’ll do a deep dive on DIDs and did:prism specifically\n\ndid:prism methods\ncanonical vs longform DID",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>DIDs</span>"
    ]
  },
  {
    "objectID": "section3/diddocuments.html",
    "href": "section3/diddocuments.html",
    "title": "13  DID Documents",
    "section": "",
    "text": "DIDDocuments:\n\nResolvers\nControllers",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>DID Documents</span>"
    ]
  },
  {
    "objectID": "section3/connections.html",
    "href": "section3/connections.html",
    "title": "14  Connections",
    "section": "",
    "text": "We will discuss the concept of Connections, PeerDIDs, and what it means to connect with another Peer, what’s happening under the hood and different ways to handle the process in your application.\nAlso discussed:\n\nManaging Invites\n\nOOB\nManual Accept\nAuto Accept\nDIDLess Connections (Atala Roadmap)",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Connections</span>"
    ]
  },
  {
    "objectID": "section3/verifiable-credentials.html",
    "href": "section3/verifiable-credentials.html",
    "title": "15  Verifiable Credentials",
    "section": "",
    "text": "15.1 Overview\nVerifiable Credentials are an integral part of Self-Sovereign Identity, allowing individuals to keep and control how their personal information is shared.\nA Verifiable Credential (VC) is a digital statement made by an Issuer about a Subject. This statement is cryptographically secured and can be verified by a third party without the need for the Verifier to directly contact the Issuer. Verifiable Credentials are used to represent information such as identity documents, academic records, professional certifications, and other forms of credentials that traditionally exist in paper form. Coupled with other technology such as Self-Sovereign Identity, Verifiable Credentials can unlock novel and exciting use cases.\nComponents of a Verifiable Credential:\nHow Verifiable Credentials Work:\nBenefits of Verifiable Credentials:\nUse Cases:",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Verifiable Credentials</span>"
    ]
  },
  {
    "objectID": "section3/verifiable-credentials.html#overview",
    "href": "section3/verifiable-credentials.html#overview",
    "title": "15  Verifiable Credentials",
    "section": "",
    "text": "Issuer: The entity that creates and signs the credential. This could be an organization, institution, government entity or individual.\nHolder: The entity or individual to whom the credential is issued to and who can present proof to a Verifier.\nVerifier: The entity or individual that checks the authenticity and validity of the credential trough requesting proof from a Holder.\nSubject: The entity or individual about which the claims are made. In many cases, the Holder and the Subject are the same entity.\nClaims: Statements about the Subject, such as “Alice has an Educational Credential from Vienna University.”\nProof: Cryptographic evidence, using Digital Signatures, that the credential is authentic and has not been tampered with.\nMetadata: Additional contextual information which may have content or application specific meaning, like expiration date or credential description.\n\n\n\nIssuance: The issuer creates a credential containing claims about the subject, the subject DID (public key) and signs it with their private key.\nStorage: The holder receives the credential and stores it in a digital wallet.\nPresentation: When required, the holder presents the credential to a verifier. Selective Disclosure can be used to reveal only relevant context about a claim, and not all user data.\nVerification: The verifier checks the credential’s authenticity by validating the issuer’s digital signature and ensuring the credential has not been tampered with.\n\n\n\nInteroperability: VCs follow standard formats, making them compatible across different systems and platforms.\nPrivacy: Holders can share only the necessary information, protecting their privacy.\nSecurity: Cryptographic techniques ensure the integrity and authenticity of credentials.\nDecentralization: VCs do not rely on a central authority for verification, reducing single points of failure.\n\n\n\nDigital Identity: Proof of identity for accessing services.\nEducation: Digital diplomas and certificates.\nHealthcare: Vaccination records and medical certificates.\nEmployment: Professional qualifications and work experience.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Verifiable Credentials</span>"
    ]
  },
  {
    "objectID": "section3/verifiable-credentials.html#formats",
    "href": "section3/verifiable-credentials.html#formats",
    "title": "15  Verifiable Credentials",
    "section": "15.2 Formats",
    "text": "15.2 Formats\n\nFormats (just mention types, details later in Issuing)\n\nW3C\nJWT\nSD-JWT\nAnonCreds",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Verifiable Credentials</span>"
    ]
  },
  {
    "objectID": "section3/verifiable-credentials.html#schemas",
    "href": "section3/verifiable-credentials.html#schemas",
    "title": "15  Verifiable Credentials",
    "section": "15.3 Schemas",
    "text": "15.3 Schemas\n\nSchemas\nPublishing your Schema",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Verifiable Credentials</span>"
    ]
  },
  {
    "objectID": "section3/verifiable-credentials.html#issuing",
    "href": "section3/verifiable-credentials.html#issuing",
    "title": "15  Verifiable Credentials",
    "section": "15.4 Issuing",
    "text": "15.4 Issuing\n\nJWT\nSD-JWT (Atala Roadmap Q2)\nAnonCreds",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Verifiable Credentials</span>"
    ]
  },
  {
    "objectID": "section3/verifiable-credentials.html#updating",
    "href": "section3/verifiable-credentials.html#updating",
    "title": "15  Verifiable Credentials",
    "section": "15.5 Updating",
    "text": "15.5 Updating\n\nUpdating (re-binding)",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Verifiable Credentials</span>"
    ]
  },
  {
    "objectID": "section3/verifiable-credentials.html#revoking",
    "href": "section3/verifiable-credentials.html#revoking",
    "title": "15  Verifiable Credentials",
    "section": "15.6 Revoking",
    "text": "15.6 Revoking\n\nRevoking",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Verifiable Credentials</span>"
    ]
  },
  {
    "objectID": "section3/didcomm.html",
    "href": "section3/didcomm.html",
    "title": "16  DIDComm",
    "section": "",
    "text": "16.1 Overview\nDIDComm v2 (Decentralized Identifier Communication version 2) is a set of communication protocols designed to enable secure, private, and interoperable messaging between DIDs. These protocols have been adopted throughout Identus to standardize many important interactions, like sending and receiving encrypted messages between a mediator its peers.\nDIDComm Messaging messages are encrypted JSON Web Message (JWM) envelopes. They have a standard structure including headers, a body, and optional attachments, which are encrypted and signed to ensure security and integrity.\nFor details on how messages are sent and received in Identus, see Mediators",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>DIDComm</span>"
    ]
  },
  {
    "objectID": "section3/didcomm.html#sending-messages",
    "href": "section3/didcomm.html#sending-messages",
    "title": "16  DIDComm",
    "section": "16.2 Sending Messages",
    "text": "16.2 Sending Messages",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>DIDComm</span>"
    ]
  },
  {
    "objectID": "section3/didcomm.html#sending-files",
    "href": "section3/didcomm.html#sending-files",
    "title": "16  DIDComm",
    "section": "16.3 Sending Files",
    "text": "16.3 Sending Files",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>DIDComm</span>"
    ]
  },
  {
    "objectID": "section3/verification.html",
    "href": "section3/verification.html",
    "title": "17  Verification",
    "section": "",
    "text": "Verification\n\nPresenting Proof\nPresentation Policies / Verification Policies\nSelective Disclosure with AnonCreds",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Verification</span>"
    ]
  },
  {
    "objectID": "section3/plugins.html",
    "href": "section3/plugins.html",
    "title": "18  Plugins",
    "section": "",
    "text": "This is a placedholer for the topic of Plugins. Identus plugins have not been officially announced yet but are on the IOG roadmap for 2024, Q4. If there is any information by the time we publish we will write about them.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Plugins</span>"
    ]
  },
  {
    "objectID": "section4/installation-production.html",
    "href": "section4/installation-production.html",
    "title": "19  Installation - Production Environment",
    "section": "",
    "text": "In this chapter we will discuss how to prepare a production envioronment for an Identus application.\nWe will discuss:\n\nHardware recommendations\nProduction configuration and security\nLock down Docker / Postgres (default password hole, etc)\nSSL\nMulti Tenancy\nKeycloak\nTestnet / Preprod env\nConnecting to Mainnet\nSet up Cardano Wallet\nKey Management with HashiCorp\nConnecting to Cardano\nRunning dbSync",
    "crumbs": [
      "Section IV - Deploy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Installation - Production Environment</span>"
    ]
  },
  {
    "objectID": "section4/mediator.html",
    "href": "section4/mediator.html",
    "title": "20  Mediator",
    "section": "",
    "text": "20.1 Overview\nA Self-Sovereign Identity Mediator is a service that enables private and secure connections between peers. Its primary function is to relay encrypted messages between DIDs using DIDComm V2 protocols. Since each participant wallet is Self-Sovereign, Mediators help route messages to their intended recipient without any one wallet knowing the details of the other. Encrypted messages can be sent to peers even if they are not online, and the Mediator will manage a queue for the offline party until they are able to connect and retrieve them.\nThink of a Mediator like a set of Post Office mailboxes. Each mailbox has a mailing address (a DID). Each mailbox can hold an stack of incoming mail Encrypted DIDComm V2 messages for its owner. Each mailbox also keeps a list of cryptographic Connections with whom its owner can send or receive mail with. In this way, Identus Mediators facilitate all types of important transactions, including routing both messages, Verifiable Credential issuance, and Credential Exchange.\nWhat’s important is that the Mediator, while messages are routed through it, is not a centralized actor. Mediators can not know the contents of any message, only what DIDs can talk to other DIDs and what encrypted messages they have yet to read.",
    "crumbs": [
      "Section IV - Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Mediator</span>"
    ]
  },
  {
    "objectID": "section4/mediator.html#overview",
    "href": "section4/mediator.html#overview",
    "title": "20  Mediator",
    "section": "",
    "text": "20.1.1 Why use a Mediator?\nWhy do we need a Mediator in the first place? If participants are Self-Sovereign, then why not connect an edge wallet directly to another edge wallet?\nSSI participants are connected through various types of devices and network conditions. The Cloud Agent, is expected to be online and available all the time, as it’s hosted in a remote server farm somewhere. However users who keep their wallets on mobile devices, or laptop computers, are only online sporadically, and can’t be expected to have a reliable connection to the Internet at all times. This is where Mediators earn their keep. If User A were to send a message to User B, who happens to be offline at the moment, the message could not be delivered, plus User A would also have to know sensitive data about how to contact User B. If User B changes devices, they would have to tell User A, and all other peer Connections. If User A instead, sends the message through the Mediator, it can be held securely and retrieved the next time User B connects to the Internet. Mediators provide reliability between Connections, without compromising privacy or security.",
    "crumbs": [
      "Section IV - Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Mediator</span>"
    ]
  },
  {
    "objectID": "section4/mediator.html#set-up-a-mediator",
    "href": "section4/mediator.html#set-up-a-mediator",
    "title": "20  Mediator",
    "section": "20.2 Set up a Mediator",
    "text": "20.2 Set up a Mediator\nWe will teach the reader how to\n\nInstall, configure, and Run your own Mediator\nHow to manage Websockets\nPerformance Tuning",
    "crumbs": [
      "Section IV - Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Mediator</span>"
    ]
  },
  {
    "objectID": "section4/maintenance.html",
    "href": "section4/maintenance.html",
    "title": "21  Maintenance",
    "section": "",
    "text": "Mastering Identus means maintaing your application once it’s launched.\nIn this chapter we will cover:\n\nObservability\n\nManage nodes / Memory\nPerformance Testing\nAnalytics with BlockTrust Analytics\n\nUpgrading Agents\n\nHow to minimize downtime\n\nHashicorp\n\nKey Management\nKey rotation",
    "crumbs": [
      "Section IV - Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Maintenance</span>"
    ]
  },
  {
    "objectID": "section5/trust-registries.html",
    "href": "section5/trust-registries.html",
    "title": "22  Trust Registries",
    "section": "",
    "text": "Overview of the concept of a Trust Registry\n\nWhat role they play in SSI\nTrust Over IP Trust Registry Spec\nHighlight any real world examples if they exist by book completion",
    "crumbs": [
      "Section V - Addendum",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Trust Registries</span>"
    ]
  },
  {
    "objectID": "section5/continuing-your-journey.html",
    "href": "section5/continuing-your-journey.html",
    "title": "23  Continuing on Your Journey",
    "section": "",
    "text": "Information about becoming a Contributor to Identus\n\nHow to contribute to the source code or documentation\n\nInformation about how to get involved in the SSI community outside of Identus\nTrust over IP (ToIP)\nTrust Over IP (ToIP) comprises over 300 organizations from diverse industries collaborating to advance Decentralized Identity through ideas and software. According to ToIP, “We develop tools and specifications to help communities of any size use digital networks to build and strengthen trust between participants.”\nThe ToIP Stack, published in 2019, describes how the four layers (DIDs, DIDComm Protocol, Data Exchange Protocols, and Application Ecosystems) form a secure, scalable, and interoperable digital trust framework. Introduction to ToIP, Version 2.0, released in 2021, is an excellent resource for anyone catching up on the Digital Identity problem and solution. Membership options include free Contributor accounts and paid memberships, providing access to ToIP’s resources and Slack channels for collaboration.\nTo join Trust Over IP, you need to create a free Linux Foundation account and then complete your ToIP application here.\nAll members agree to open, non-competitive participation, so please have your legal team review all associated documents during the onboarding process.\nFor further details, refer to The ToIP Stack and Overview.\nDecentralized Identity Foundation (DIF)",
    "crumbs": [
      "Section V - Addendum",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Continuing on Your Journey</span>"
    ]
  },
  {
    "objectID": "errata.html",
    "href": "errata.html",
    "title": "24  Errata",
    "section": "",
    "text": "Errata goes here\nWe will list any bugs that may have been “printed” in certain editions of the book.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Errata</span>"
    ]
  },
  {
    "objectID": "glossary.html",
    "href": "glossary.html",
    "title": "Glossary",
    "section": "",
    "text": "Glossary or Index here\nThis will reference key concepts and Identus terms and where they are mentioned in the book, allowing someone to look up a term and know what section it is referenced in.\nTODO: First draft will just lay down the glossary terms, we want to add detailed descriptions later.\n\nVDR\n\nVerifiable Data Registry",
    "crumbs": [
      "Appendices",
      "Glossary"
    ]
  }
]
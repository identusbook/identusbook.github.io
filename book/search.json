[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Mastering Identus: A Developer Handbook",
    "section": "",
    "text": "Welcome\nWelcome to the book!",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "copyright.html",
    "href": "copyright.html",
    "title": "1  Copyright",
    "section": "",
    "text": "IdentusBook.com\nCopyright @2024 Jon Bauer and Roberto Carvajal\nAll rights reserved\nPlease see our License for more information about fair use.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Copyright</span>"
    ]
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "2  License",
    "section": "",
    "text": "2.1 Book Content:\nThe content of the book (text, printed code, and images) are licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0\nThe intent here is to allow anyone to use or excerpt from the book as long as they credit the source. In general we are very open to having our work shared non-commercially. We are copyrighting this book to protect the ability to version and revise the work officially, and to keep open the door for a print version if the opportunity arises and/or makes sense.\nIf you’d like to commercially reproduce contents from this book, please contact us.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>License</span>"
    ]
  },
  {
    "objectID": "license.html#applications",
    "href": "license.html#applications",
    "title": "2  License",
    "section": "2.2 Applications:",
    "text": "2.2 Applications:\nThe example code that accompanies this book is licensed under a MIT License\nThis allows anyone to freely take, modify, or redistribute the code as long as they also assign the MIT license to it.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>License</span>"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "4  Preface",
    "section": "",
    "text": "Explains who the authors are and why we were motivated to write this book.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "section1/introduction.html",
    "href": "section1/introduction.html",
    "title": "5  Introduction",
    "section": "",
    "text": "This is a developer-centric book about creating and launching Self-Sovereign applications with Identus. We aim to show the reader how to configure, build and deploy a complex idea from scratch.\nThis is not a book about Self-Sovereign Identity. There are already great resources available on that topic. If you’re new to the idea of SSI or Identus, we recommend the excellent resources listed below as a pre-requisite to this text.\n\nSelf-Sovereign Identity by Alex Preukschat, Drummond Reed, et al. This is the definitive book on SSI and it’s ecosystem of topics.\nIdentus Documentation\n\nIt should be noted that Identus is still new and at the time of writing this book, there are very few best practices, in fact, very little practices at all. A handful of adventurous developers have been building on the platform and sharing their experiences, and we hope to share our own learnings in hopes of magnifying that knowledge and helping developers skip the common pitfalls and bring their ideas to market.\nWe hope this text will be accessible to anyone who’s curious about what’s\nWe hope that newcomers will be able to use this text to skip common pitfalls and misunderstandings, and bring their ideas to market faster.\nWe’re glad you could join us :)",
    "crumbs": [
      "Section I",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "section1/ssi-basics.html",
    "href": "section1/ssi-basics.html",
    "title": "6  SSI Basics",
    "section": "",
    "text": "[SSI Roles/Conceptual Diagram (Triangle of Trust)]\nIssuer:\nThe entity that issues a Verifiable Credential to a Holder. This could be a bank, government agency or anyone that accepts responsibility for making credentials. For example a governmental agency can issue a passport to a citizen, or a gym can issue a membership to a member. The type of agency is not important, only that they issue a credential. This role accepts responsibility for having issued that credential and should look to establish trust and reputation with Holders and Verifiers. The Issuer’s DID will be listed in the Issuer (iss:) field of a Verifiable Credential and can be inspected by anyone wishing to know the origin of the credential.\nHolder:\nA Holder is simply any person or wallet that holds a Verifiable Credential. Verifiable Credentials can represent anything, a gym membership, an accomplishment like a University degree, or a permission set, such as a login or authentication role.\nVerifier:\nA Verifier is any person or wallet that performs a verification on a Verifiable Credential or any of it’s referenced entities. A Verifier might perform a check on cryptographic elements of a VC, or make sure that the Issuer DID belongs to the expected entity. Verifiers usually only care to double check that the Verifiable Credential is legitimate and that the included claims meet their expectations, for example when a bartender checks the age of a patron before serving them alcohol.\nTrust Registry:\nWhen Verifiers need to know who a DID belongs to, there needs to be a way to look up that information. A Trust Registry is a mapping between DIDs and the entities they represent. You can think of this like a phone book for DIDs. Trust Registries need to be trusted themselves, and can be as broad or as specific as they need to be. For example, an Real Estate specific Trust Registry that lists real estate agents can be a way to validate that a particular agent is an accepted member of that industry.",
    "crumbs": [
      "Section I",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>SSI Basics</span>"
    ]
  },
  {
    "objectID": "section1/identus-concepts.html",
    "href": "section1/identus-concepts.html",
    "title": "7  Identus Concepts",
    "section": "",
    "text": "[Identus Application Architecture Diagram]\nIdentus is made up of several open source components. Each could be used or forked separately but they are designed to work well together.\nPRISM Node:\nPRISM Node implements the did:prism methods and is an interface to multiple VDR (Verifiable Data Registries). The node can resolve PRISM DIDs and write transactions to a blockchain or database. PRISM Node is expected to be online at all times.\nCloud Agent:\nWritten in Scala, the Cloud Agent runs on a server and communicates with clients and peers via a REST API. It is a critical component of an Identus application, able to manage identity wallets and their associated operations, as well as issue Verifiable Credentials. The Cloud Agent is expected to be online at all times.\nEdge Agent:\nEdge Agents give agent capabilities to clients like Websites and mobile apps. They can can never be assumed to be online at any given time, and therefore rely on sending and receiving all communications through an online proxy, the Mediator.\nDIDComm:\nDIDComm is a private, secure, and interoperable protocol for communication between decentralized identities. Identus supports DIDCommV2 and allows peers to pass messages between each other, proxied by the Mediator. Messages contain a to: and from: DID\nMediator:\nMediators act as middlemen between Peer DIDs. In order for any agent to send a message to any other agent, it must know the to and from DIDs of each message. The sender and recipient together make up a cryptographic connection called a DIDPair. Mediators maintain queues of messages for each DIDPair. If an Edge Agent is offline, the Mediator will hold incoming messages for them until the agent is back online and able to receive them. Mediators can deliver messages when polled, or push via web sockets. Mediators are expected to be online at all times and be highly available.\nSince instantiation of Identus Edge Agents requires a Mediator, there are several publicly available Mediator services which make development simple.\n\nPRISM Mediator\nRootsID Mediator\nBlocktrust Mediator\n\nWhile extremely helpful during development, these are not recommended for production Identus deployments as they have no uptime guarantee and will not scale past a small number of concurrent users. We will discuss how to run your own Mediator in Chapter 18\nBuilding Blocks:\nIdentus separates the handling of important SSI operations into separate, focused libraries.\nApollo: Apollo is a cryptographic primitives toolbox, which Identus uses to ensure data integrity, authenticity, and confidentiality.\nCastor: Castor enables creation, management, and resolution of DIDs.\nPollux: Pollux handles all Verifiable Credential operations.\nMercury: Mercury is an interface to the DIDCommV2 protocol, allowing the sending and receiving of messages between DIDs.\nMore info on each of the Building Blocks can be found in the Docs",
    "crumbs": [
      "Section I",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Identus Concepts</span>"
    ]
  },
  {
    "objectID": "section2/installation-local.html",
    "href": "section2/installation-local.html",
    "title": "8  Installation - Local Environment",
    "section": "",
    "text": "8.1 Overview\nHyperledger Identus, previously known as Atala PRISM, is distributed across various repositories. These repositories group together different building blocks to provide the necessary functionality for fulfilling each of the essential roles in Self-Sovereign Identity (SSI), as introduced in Identus Concepts and SSI Basics. Throughout this book, we will detail the setup of each component.\nThe initial component to set up is our Cloud Agent. This agent is responsible for creating and publishing DID Documents into a Verifiable Data Registry (VDR), issuing Verifiable Credentials, and, depending on the configuration, even providing Identity Wallets to multiple users through a multi-tenancy setup. For now, our focus will be on setting up the Cloud Agent to run locally in development mode, supporting only a single tenant. This step is crucial for learning the basics and getting started. As we progress and build our example application, we will deploy the Cloud Agent in development mode first, then set it up to connect to Cardano testnet as our VDR on pre-production mode and, finally, in production mode with multi-tenancy support connected to Cardano mainnet. This will be a gradual process as we need to familiarize on each stage of the Cloud Agent.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Installation - Local Environment</span>"
    ]
  },
  {
    "objectID": "section2/installation-local.html#identus-releases-overview",
    "href": "section2/installation-local.html#identus-releases-overview",
    "title": "8  Installation - Local Environment",
    "section": "8.2 Identus Releases Overview",
    "text": "8.2 Identus Releases Overview\nIdentus is built upon multiple interdependent building blocks, including the Cloud Agent, Wallet SDK, Mediator, and Apollo Crypto Library. To ensure compatibility among these components, it is crucial to identify the correct building block versions that are compatible between them. Identus releases are listed [here] (https://github.com/hyperledger/identus/releases). The release notes for each vesion provides a compatibility table for each Identus release. This guide will focus on the latest stable Identus release at the time of writing (December 2024).",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Installation - Local Environment</span>"
    ]
  },
  {
    "objectID": "section2/installation-local.html#pre-requisites",
    "href": "section2/installation-local.html#pre-requisites",
    "title": "8  Installation - Local Environment",
    "section": "8.3 Pre-requisites",
    "text": "8.3 Pre-requisites\n\n8.3.1 Java\nbrew install openjdk@21\n\n\n8.3.2 sbt\nbrew install sbt\n\n\n8.3.3 Git\nIf you’re using a UNIX-based system (such as OS X or Linux), you likely already have git installed. If not, you can download the installer from Git downloads. Additionally, various GUI clients are available for those who prefer a graphical interface.\nTo clone the Cloud Agent repository, first go to the Releases page and identify the tagged release corresponding to the Identus release you are targeting (e.g. cloud-agent-v1.40.0 is part of Identus v2.14 release), then clone the repository with this command:\ngit clone --depth 1 --branch cloud-agent-v1.40.0 https://github.com/hyperledger/identus-cloud-agent\n\n\n\n\n\n\nNote\n\n\n\nUsing --depth 1 will skip the history of changes in the repository up until the point of the tag, this is optional.\n\n\n\n\n8.3.4 Docker\nThe Cloud Agent and Mediator are distributed as Docker containers, which is the recommended method for starting and stopping the various components required to run the cloud infrastructure.\nTo begin, install Docker Desktop, which provides everything you need to get started.\n\n\n8.3.5 WSL\nFor Windows users, please refer to How to install Linux on Windows with WSL.\n\n\n\n\n\n\nNote\n\n\n\nWindows is the least tested environment, the community has already found some issues and workarounds on how to get the Cloud Agent working. We will try to always include instructions regarding this use case.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Installation - Local Environment</span>"
    ]
  },
  {
    "objectID": "section2/installation-local.html#before-we-run-the-agent",
    "href": "section2/installation-local.html#before-we-run-the-agent",
    "title": "8  Installation - Local Environment",
    "section": "8.4 Before We Run The Agent",
    "text": "8.4 Before We Run The Agent\nOnce you have cloned the identus-cloud-agent repository and Docker is up and running you can jump right ahead and run the agent, but before we do that if you are not yet familiar with the community projects or the structure of the agent itself, we recommend you to spend a little time exploring the following information, this is optional and you can skip it.\n\n8.4.1 Atala Community Projects\nThere is a growing list of community repositories that aim to provide some extra functionality, mostly maintained by official developers and community members on their spare time.\nSome notable projects are:\n\nPluto Encrypted: Implementation of Pluto storage engine with encryption support.\nIdentus Store A secure light-weight and dependency free database wrapper.\nNeoPrism Resolver: A did:prism resover and explorer.\nBlocktrust Mediator A DIDCommv2 compliant mediator, written in C#.\nEdge Agent SDK Demos: Browser and Node versions of Edge Agent SDK integrated with Pluto Encrypted.\nIdentus Test: Shell script helper that will checkout a particular Identus release and compatible components.\n\n\n\n8.4.2 Exploring The Repository\nThere are two fundamental directories inside the repository if you are an end user.\n\ndocs Where all the latest technical documentation will be available, this includes the Architecture Decision Records (ADR), general insights, guides to deploy, examples and tutorials about how to handle VC Schemas, Connections, secrets, etc. We will do our best to explain in detail all this procedures as we build our example app.\ninfrastructure This directory holds the agent’s Docker file and related scripts to run the agent in different modes such as dev, local or multi. The way to change the agent setup is by customizing environmental variables trough the Docker file, so we really advise you to get familiar with the shared directory content, because that’s the base for every other mode, in essence, every mode is a customization of the shared Docker file.\n\nOur first mode to explore and the simplest one should be local mode, which by default will run a single agent as a single-tenant, meaning that this instance will control only a single Identity Wallet that will be automatically created and seeded upon the first start of the agent.\nThe multi mode essentially runs 3 different local agents but each is assigned a particular role such as issuer, holder and verifier. This is useful in order try test more complex interactions between independent actors.\nFinally the dev mode is meant to be used for development and provides an easy way to modify the Cloud Agent source code, it does not rely on the pre-built Docker images that the local mode fetches and run. We will not use this mode at all trough the book but feel free to explore this option if you would like to make contributions to the Cloud Agent in the future.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Installation - Local Environment</span>"
    ]
  },
  {
    "objectID": "section2/installation-local.html#running-the-cloud-agent",
    "href": "section2/installation-local.html#running-the-cloud-agent",
    "title": "8  Installation - Local Environment",
    "section": "8.5 Running The Cloud Agent",
    "text": "8.5 Running The Cloud Agent\n\n8.5.1 Environment Variables\nInside infrastructure/local directory, you will find three important files, run.shand stop.sh scripts and the .env file.\nOur local environment file should look like this\nAGENT_VERSION=1.40.0\nPRISM_NODE_VERSION=2.5.0\nVAULT_DEV_ROOT_TOKEN_ID=root\nThis will tell Docker which versions of the Cloud Agent and PRISM Node to run, plus a default value for the VAULT_DEV_ROOT_TOKEN_ID, this value corresponds to the HashiCorp Token ID. HashiCorp is a secrets storage engine and it will become relevant later on when we need to prepare the agent to run in prepod and production modes, for now the local mode will ignore this value because by default it will use a local postgres database for it’s secret storage engine.\nThe run.sh script options:\n./run.sh --help\nRun an instance of the ATALA bulding-block stack locally\n\nSyntax: run.sh [-n/--name NAME|-p/--port PORT|-b/--background|-e/--env|-w/--wait|--network|-h/--help]\noptions:\n-n/--name              Name of this instance - defaults to dev.\n-p/--port              Port to run this instance on - defaults to 80.\n-b/--background        Run in docker-compose daemon mode in the background.\n-e/--env               Provide your own .env file with versions.\n-w/--wait              Wait until all containers are healthy (only in the background).\n--network              Specify a docker network to run containers on.\n--webhook              Specify webhook URL for agent events\n--webhook-api-key      Specify api key to secure webhook if required\n--debug                Run additional services for debug using docker-compose debug profile.\n-h/--help              Print this help text.\nFor our first interaction with the agent all we have to do is to call the run script. If you have any conflicts with the port 80 already in use or you don’t want that as the default, you can pass --port 8080 or any other available port that you would like to use.\nSo, from the root of the repository you can run:\n./infrastructure/local/run.sh\nThis will take a while the first time as Docker will fetch the required container images and get them running. To check the status of the Cloud Agent you can use curl or open a browser window at same endpoint URL (make sure to specify a custom port if you changed it in the previous step, e.g. use http://localhost:8080):\ncurl http://localhost/cloud-agent/_system/health\n{\"version\":\"1.33.0\"}\nThe version should match the version of the Cloud Agent defined in the .envfile.\nTo stop the agent, you can press Control + C or run:\n./infrastructure/local/stop.sh\nCongratulations! you have successfully setup the agent in local mode. Next we will explore our Docker file in detail and interact with our agent using the REST API.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Installation - Local Environment</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html",
    "href": "section2/agent-rest-api.html",
    "title": "9  Agent REST API",
    "section": "",
    "text": "9.1 The Cloud Agent API\nThe only way to interact with our newly created Cloud Agent is trough the REST API, this means any action of the Cloud Agent such as establishing connections, creating Credential Schemas, issuing Verifiable Credentials, etc. will be triggered trough the agent API endpoints.\nIt is crucial to understand that the API is essentially an abstraction of the agent’s Identity Wallet. In our initial setup our agent is running on single-tenant mode, therefor it is managing a single default wallet which is assigned the following Entity ID (UUID) 00000000-0000-0000-0000-000000000000. You can confirm this by running the following command:\nLater on the book, once we start building our example app, we will setup the agent in multi-tenant mode, meaning that a single agent instance will be capable of managing multiple wallets, we refer to those wallets as custodian wallets. This more advanced setup is useful when your users would want to delegate their Identity Wallet custody to a service instead of managing the wallet themselves.\nBesides the _system/health endpoint we used earlier to confirm the agent version, there is one more endpoint used to debug runtime metrics:\nThis will be useful when debugging a memory or performance issue or when developing.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html#the-cloud-agent-api",
    "href": "section2/agent-rest-api.html#the-cloud-agent-api",
    "title": "9  Agent REST API",
    "section": "",
    "text": "docker logs local-cloud-agent-1 | grep \"default\"\n\n\n... Initializing default wallet.\n... Default wallet seed is not provided. New seed will be generated.\n... Entity created: Entity(00000000-0000-0000-0000-000000000000,default,00000000-0000-0000-0000-000000000000,1970-01-01T00:00:00Z,1970-01-01T00:00:00Z)\n\n\ncurl http://localhost/cloud-agent/_system/metrics\n# HELP jvm_memory_bytes_used  \n# TYPE jvm_memory_bytes_used gauge\njvm_memory_bytes_used{area=\"heap\",} 1.07522616E8\njvm_memory_bytes_used{area=\"nonheap\",} 1.74044936E8\n...",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html#openapi-specification",
    "href": "section2/agent-rest-api.html#openapi-specification",
    "title": "9  Agent REST API",
    "section": "9.2 OpenAPI Specification",
    "text": "9.2 OpenAPI Specification\nThe OpenAPI Specification (OAS) defines a standard, language-agnostic interface to HTTP APIs. The Cloud Agent API documentation can be found at https://hyperledger.github.io/identus-docs/agent-api/ and besides being very detailed and always updated to the latest, it also comes with the OAS spec yaml file that will allow us to setup Postman to easily test our API or use the same OAS standard to auto generate code for client libraries on different language stacks. We will not attempt to repeat this API documentation in the book, rather lets focus on complement the existing documentation and explain with more detail how everything works.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html#apisix-gateway",
    "href": "section2/agent-rest-api.html#apisix-gateway",
    "title": "9  Agent REST API",
    "section": "9.3 APISIX Gateway",
    "text": "9.3 APISIX Gateway\nAPISIX is in charge of proxying different services inside the container, exposing three routes trough the port you specified to the run.sh script (remember it runs on port 80 by default).\n\nhttp://localhost/cloud-agent/ This will be the Cloud Agent API.\nhttp://localhost/apidocs/ Swagger UI interface test the API.\nhttp://localhost/didcomm/ Our public DIDCOMM endpoint, this is our communication channel and it’s how we send end to end encrypted messages to another peer trough a mediator. We will take a deep dive into DIDCOMM later in the book.\n\nAPISIX by default will just expose this services but trough plugins it can be setup as Ingress controller, load balancer, authentication and much more. You can read the APISIX documentation to learn more.\n\n\n\n\n\n\nWarning\n\n\n\nThis is where CORS (Cross-Origin Resource Sharing) is setup, be default it will allow any origin, here you can restrict which domains should be allowed to connect to this endpoints. We will revisit this on our customization guide.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html#swagger-ui",
    "href": "section2/agent-rest-api.html#swagger-ui",
    "title": "9  Agent REST API",
    "section": "9.4 Swagger UI",
    "text": "9.4 Swagger UI\nSwagger UI it’s a visualization and interactive tool to explore an API. It’s automatically generated from your OpenAPI (formerly known as Swagger) Specification and it’s often used to support the API documentation.\nOur Cloud Agent Docker file includes a container for Swagger UI that is exposed trough APISIX as explained earlier. This means you can use this tool right away after the agent is running.\nTo use it, just open http://localhost/apidocs/ in your browser and from the server list select:\n\nhttp://localhost/cloud-agent - The local instance of the Cloud Agent behind the APISIX proxy.\n\nThen, click the Authorize button and a small modal window will popup, in there you need to define an apikey, even if by default you haven’t defined one, this means you can put any value in here, of course later in the book when we set an actual apikey you will need to use it here, for now just use test as value and it should be fine.\nAfter authorizing, the modal should look like this:\n\n\n\nSwagger UI Apikey Modal\n\n\nYou can close that modal window and try your first request, click to expand the GET /connections endpoint and click Try it out button, that will enable the text inputs for any available parameters, for now, all three parameters should be blank (offet, limit, thid).\nFinally, just click the Execute button to actually perform the request. This should return something like this:\n{ \"contents\": [], \"kind\": \"ConnectionsPage\", \"self\": \"\", \"pageOf\": \"\" }\nCongratulations! you have connected to the API and asked for a list of connections, right now there are no connections so the empty array you get back is correct.\n\n\n\n\n\n\nNote\n\n\n\nYou can use Swagger UI to copy curl commands that you can paste in your terminal, this will run exactly the same API request. For example:\ncurl -X 'GET' \\\n  'http://localhost/cloud-agent/connections' \\\n  -H 'accept: application/json' \\\n  -H 'apikey: test'\n{\"contents\":[],\"kind\":\"ConnectionsPage\",\"self\":\"\",\"pageOf\":\"\"}",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html#postman",
    "href": "section2/agent-rest-api.html#postman",
    "title": "9  Agent REST API",
    "section": "9.5 Postman",
    "text": "9.5 Postman\nPostmanis perhaps the most popular API tool among developers, it allow us to easily interact and debug API endpoints but has many killer feature like enabling teams to share and work together on the same API, run automated tests, automatically renew tokens, keeps the state of your interactions with the API, copy code snippets to make API calls over many languages, etc. So it’s really a better overall option versus the Swagger UI interface or just directly using curl.\nThe big time saver for us is that because it supports OAS, we can easily import the whole API definition. So, let’s try it:\n\nIf you don’t already have it, first you should Download Postman and Sign Up for a free account.\nHead to the API docs and click the Download button, or copy this direct link https://hyperledger.github.io/identus-docs/redocusaurus/plugin-redoc-0.yaml\nInside Postman, go to File -&gt; Import and either drag & drop your yaml file if you downloaded it or paste the URL in the box, this will auto advance to the next step.\nOn the “How to import” step select “OpenAPI 3.0 with a Postman Collection” and click import.\n\nIf everything goes correctly, you should see “Identus Cloud Agent API Reference” in your collections.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section2/agent-rest-api.html#tutorials",
    "href": "section2/agent-rest-api.html#tutorials",
    "title": "9  Agent REST API",
    "section": "9.6 Tutorials",
    "text": "9.6 Tutorials\nThe official documentation contains a tutorials section with detailed walkthroughs for each of the most important interactions like connecting to another peer, managing DIDs, managing VC Schemas, issuing a VC, etc. We highly encourage you to follow those and get familiar with the API, this will come in very handy very soon when we start building our own example app.",
    "crumbs": [
      "Section II - Getting Started",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Agent REST API</span>"
    ]
  },
  {
    "objectID": "section3/project-overview.html",
    "href": "section3/project-overview.html",
    "title": "10  Example Project",
    "section": "",
    "text": "10.1 Overview - Airline Ticket Wallet\nOne of the best ways to learn and understand a software platform is to build something with it. In the following chapters, we will build an example application showing how to use Identus to issue and verify airline tickets.\nUsers will be able to purchase a flight, and receive a Verifiable Credential representing a ticket and seat assignment. Travelers will be able to present their ticket to Airport Security when requested, and in turn, the security officer will be able to verify the ticket’s authenticity.\nWe will use the Identus Cloud Agent, plus the Typescript SDK in our examples, however the same functionality and source is available in the native language of each Edge Agent SDK; Swift for iOS/Mac and Kotlin for Android. Please see the book’s Github page for the complete source code and follow along in your language of choice.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example Project</span>"
    ]
  },
  {
    "objectID": "section3/project-overview.html#prerequisites",
    "href": "section3/project-overview.html#prerequisites",
    "title": "10  Example Project",
    "section": "10.2 Prerequisites",
    "text": "10.2 Prerequisites\nTo follow along with the book, please make sure you have a working Cloud Agent development environment, as described in the Section 2.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example Project</span>"
    ]
  },
  {
    "objectID": "section3/project-overview.html#roles",
    "href": "section3/project-overview.html#roles",
    "title": "10  Example Project",
    "section": "10.3 Roles",
    "text": "10.3 Roles\n\n10.3.1 Issuer: Airline\n\n\n10.3.2 Holder: Traveler\n\n\n10.3.3 Verifier: Airport Security Officer",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example Project</span>"
    ]
  },
  {
    "objectID": "section3/wallets.html",
    "href": "section3/wallets.html",
    "title": "11  Wallets",
    "section": "",
    "text": "11.1 Overview\nWallets are an essential component on every Self-Sovereign Identity interaction, and as you might have guessed, just like in the physical world where a wallet holds your identifiers (IDs), a digital SSI wallet’s function is to store and manage Decentralized Identifiers (DIDs), Verifiable Credentials (VCs), cryptographic keys, and other related assets.\nSince many SSI frameworks rely on a Blockchain to publish DIDs, there is a common misconception that SSI wallets work in a similar way. Although both SSI and Blockchain wallets require a seed phrase built from a random set of mnemonics, thats where the overlap ends, because the balance and history of a Blockchain wallet can be restored from the ledger itself as opposed to an SSI wallet, where all the stored information exists only on the device and needs to be manually backed up and restored.\nIn essence, a wallet in SSI is piece of software that allows users to store, manage, and present proof of their digital identities and credentials. It acts as a repository for digital assets required to fulfill every SSI interaction, ensuring that users and entities have complete control over their data. In the case of Identus, the Edge Agent SDK provides all the abstractions needed to operate a wallet by an individual on a browser or mobile app, and the Cloud Agent, provides a REST API to operate a wallet in the cloud, either to itself (single tenant) or for third-parties (multi tenant) as a custodial wallet.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Wallets</span>"
    ]
  },
  {
    "objectID": "section3/wallets.html#edge-agent-sdk-in-identus",
    "href": "section3/wallets.html#edge-agent-sdk-in-identus",
    "title": "11  Wallets",
    "section": "11.2 Edge Agent SDK in Identus",
    "text": "11.2 Edge Agent SDK in Identus\nIdentus provides it’s wallet interface through the Edge Agent SDKs, available in 3 flavors:\n\nTypeScript for Web and Node apps.\nSwift for iOS and Mac.\nKotlin for Android and JVM.\n\nEach of the flavors provide the same building block implementations:\n\nApollo: Provides a suite of necessary cryptographic operations.\nCastor: Provides a suite of operations to create, manage and resolve decentralized identifiers.\nPollux: Provides a suite of operations for handling verifiable credentials.\nMercury: Provides a suite of operations for handling DIDComm V2 messages.\nPluto: Provides an interface for storage operations in a portable, storage-agnostic manner.\nAgent: A component using all other building blocks, provides basic edge agent capabilities, including implementing DIDComm V2 protocols.\n\nAnd all of them abstract the usage of each building block through the Agent component.\nMost of the time you will be operating the wallet trough the Agent interface unless you require to directly call lower level building block API, for example, you may require to send a custom DIDCOMM message payload format which is not directly supported via the Agent building block, you can still use Mercury directly to achieve that. This approach gives you a simple to use interface trough the Agent but also the flexibility and control that comes with also providing access to the lower level APIs. We highly encourage to dig inside each of the building blocks and study how the Agent is using them, this will come handy when you need to add custom features to your own software.\nThere is one building block that is not implemented and only provided as an interface, this is Pluto, the storage layer for DIDs, VCs, messages, keys, etc. Identus does not have an opinion on how you should store and retrieve the contents of the wallet, so it’s your job to implement this part according to your needs. Fortunately, there is a community project providing one implementation called Pluto Encrypted, this project provides 3 different storage engines: InMemory, IndexDB, LevelDB. As the name suggest, Pluto Encrypted provides full Pluto compatibility plus handles encryption and decryption of the wallet contents, this is very important due to the fact that the wallet stores your DIDs (private keys), VCs, messages and a lot of sensitive information. If you are starting out we highly recommend you to use this implementation before attempting to role your own, it’s a great starting place that you can extend and customize to your needs.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Wallets</span>"
    ]
  },
  {
    "objectID": "section3/wallets.html#custodial-wallets",
    "href": "section3/wallets.html#custodial-wallets",
    "title": "11  Wallets",
    "section": "11.3 Custodial Wallets",
    "text": "11.3 Custodial Wallets\nIn an ideal world, everyone should be willing and able to manage their own identity wallets, this is one of the main characteristics of truly Self-Sovereign ecosystem. In practice, there are many good reasons why an identity wallet would be better managed by a service. Such is the case for companies and entities or even individuals that don’t want to deal with the responsibility and risk of self-managing their wallets. For this use case Identus provides the concept of Custodial Wallets. What this really means is that an identity wallet can be managed by the Cloud Agent and used over a REST API. For this particular use case, the Cloud Agent supports a multi-tenant mode in order to onboard and serve multiple identity wallets on the same running instance. We will explain the setup in detail over the production installation section, for now the key insight is that when you access your identity wallet through a Cloud Agent, you are really trusting the storage and management of the private keys of your identity to that service.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Wallets</span>"
    ]
  },
  {
    "objectID": "section3/dids-and-diddocuments.html",
    "href": "section3/dids-and-diddocuments.html",
    "title": "12  DIDs and DID Documents",
    "section": "",
    "text": "12.1 Overview\nA DID Document (Decentralized Identifier Document) is a JSON-LD (JavaScript Object Notation for Linked Data) structure which describes a Subject. This can represent the identity of a person, a thing, or a relationship between one or many entities. Contained in the document is information which can verify that identity without relying on a centralized authority.\nA DID (Decentralized Identifier) is the canonical representation of a DIDDocument; a portable, compact hash, which can be passed around easily or stored to a database or blockchain. A DID can be resolved, revealing the full, parsable JSON encoded DIDDocument.\nThe spec for a did:prism DIDDocument can be found here.\nAn Example DID: did:prism:4a5b5cf0a513e83b598bbea25cd6196746747f065246f1d3743344b4b81b5a74:Cr4BCrsBElsKBmF1dGgwMRJRCglzZWNwMjU2azESBHRlc3QaOmtleTE6Ly8wMjM5MmYxNjc4NmNlNmQ0NzJlOGViNzA4ZWRjMmE3OTFmZGMxNzNkNjVkNTBhODNhMTk3N2I5ZmIwMmU0MjQSWwoGYXV0aDAyElEKCXNlY3AyNTZrMRIEdGVzdBo6a2V5MjovLzAyMzkyZjE2Nzg2Y2U2ZDQ3MmU4ZWI3MDhlZGMyYTc5MWZkYzE3M2Q2NWQ1MGE4M2ExOTc3YjlmYjAyZTQyNA\nLet’s break down the format of this example DID:\nAn Example DIDDocument:\nLet’s look at the components of a DID Document:\nAn non-exhaustive example of a did:prism DIDDocument can be found here.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>DIDs and DID Documents</span>"
    ]
  },
  {
    "objectID": "section3/dids-and-diddocuments.html#overview",
    "href": "section3/dids-and-diddocuments.html#overview",
    "title": "12  DIDs and DID Documents",
    "section": "",
    "text": "did:prism: The prefix of the DID\n4a5b5cf0a513e83b598bbea25cd6196746747f065246f1d3743344b4b81b5a74: The DID identifier. This can be anything, as long as it is unique to the DID Document it is describing, and means something to your application.\nCr4BCrsBElsKBmF1dGgwMRJRCglzZWNwMjU...: The DID Document itself, encoded in base58\n\n\n{\n  \"@context\": [\n      \"https://www.w3.org/ns/did/v1\",\n      \"https://w3id.org/security/suites/jws-2020/v1\",\n      \"https://didcomm.org/messaging/contexts/v2\",\n      \"https://identity.foundation/.well-known/did-configuration/v1\"\n    ],\n  \"id\": \"did:prism:123456789abcdefghi\",\n  \"controller\": \"did:example:bcehfew7h32f32h7af3\",\n  \"verificationMethod\": [{\n    \"id\": \"did:prism:123456789abcdefghi#key-1\",\n    \"type\": \"JsonWebKey2020\",\n    \"controller\": [\"did:prism:123456789abcdefghi\"],\n    \"publicKeyJwk\": {\n      \"kty\": \"OKP\",\n      \"crv\": \"Ed25519\",\n      \"x\": \"VCpo2LMLhn6iWku8MKvSLg2ZAoC-nlOyPVQaO3FxVeQ\"\n    }\n  }],\n  \"authentication\": [\"did:prism:123456789abcdefghi#key-1\"],\n  \"assertionMethod\": [\"did:prism:123456789abcdefghi#key-1\"],\n  \"keyAgreement\": [ \"did:prism:123456789abcdefghi#key-1\"],\n  \"service\": [{\n    \"id\": \"did:prism:123456789abcdefghi#messaging\",\n    \"type\": \"DIDCommMessaging\",\n    \"serviceEndpoint\": \"https://example.com/endpoint\"\n  }]\n}\n\n\nid: The DID of the Subject described by the DIDDocument\n@context: This is an array of specifications used in this DIDDocument. The first element is usually https://www.w3.org/ns/did/v1 but any other common definitions are JSONWebSignature or DIDComm2 Messaging protocols.\ncontroller: An array of DIDs that are allowed to mutate the DIDDocument\nverificationMethod: An array of information which can be used to verify the identity of the Subject.\n\nid: The DID of the Subject\ncontroller: The DID of the Subject (author’s note: When could this be different than id?)\npublicKeyJwk or publicKeyMultibase:\n\npublicKeyJwk: A JSON Web Key (JWK) representation of the Subject’s Public Key\npublicKeyMultibase: An encoded public key using Multibase encoding\n\ntype: The type of Verification Method, ie Ed25519VerificationKey2020 or JsonWebKey2020\n\nAuthentication Methods:\n\nauthentication, assertionMethod, keyAgreement: Arrays of locations in the Subject DID, referenced in a DID + anchor format (did:prism:1234#authentication0)\n*Author’s note - Specify these in a more concrete way\n\nservice: An array of advertised methods of interacting with the Subject. These could be API endpoints for messaging or file storage systems, but any remote service can be added to add value to the DID.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>DIDs and DID Documents</span>"
    ]
  },
  {
    "objectID": "section3/dids-and-diddocuments.html#resolvers",
    "href": "section3/dids-and-diddocuments.html#resolvers",
    "title": "12  DIDs and DID Documents",
    "section": "12.2 Resolvers",
    "text": "12.2 Resolvers\nA resolver is a service that can resolve a DID to a DIDDocument. There are PRISM specific resolvers built into Identus SDKs, or you can also run your own resolver service.\nSome third-party PRISM resolvers:\n\nBlocktrust Resolver\nNeoPrism Resolver",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>DIDs and DID Documents</span>"
    ]
  },
  {
    "objectID": "section3/dids-and-diddocuments.html#controllers",
    "href": "section3/dids-and-diddocuments.html#controllers",
    "title": "12  DIDs and DID Documents",
    "section": "12.3 Controllers",
    "text": "12.3 Controllers\nControllers are entities that can mutate the DIDDocument. Controllers are specified in the DIDDocument as an array of DIDs so they can be a person, thing, or organization.\nRemember that DIDs can all be resolved to DIDDocuments, and each DIDDocument can point to people, things, machines, or services. Every mention of a DID can potentially be a chain of references to other services, or endpoints. There is plenty of room to be creative with this relationship graph.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>DIDs and DID Documents</span>"
    ]
  },
  {
    "objectID": "section3/connections.html",
    "href": "section3/connections.html",
    "title": "13  Connections",
    "section": "",
    "text": "13.1 Overview\nNow that we have a better understanding of Wallets and DIDs, it’s time to embark on our first interaction. In this chapter we are going to explore conceptually what a Connection means in SSI, take a deep dive into DID Peers, explain how they work and why they are needed for secure connections, dissect Out of Band invites and finally hands on example code to achieve connecting edge client to an agent.\nBefore we move forward we highly recommend to at least read the basic Connection tutorial on the official Identus documentation.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Connections</span>"
    ]
  },
  {
    "objectID": "section3/connections.html#connections-in-self-sovereign-identity",
    "href": "section3/connections.html#connections-in-self-sovereign-identity",
    "title": "13  Connections",
    "section": "13.2 Connections in Self-Sovereign Identity",
    "text": "13.2 Connections in Self-Sovereign Identity\nConnections are fundamental to establishing trusted interactions between peers. They enable secure and verifiable communication, allowing entities to exchange credentials and proofs in a decentralized manner. This relationship is established using a specific decentralized identifier standard (Peer DID) and is governed by a protocol (DIDComm) that ensure the authenticity, integrity, and privacy of the interactions between the connected parties.\nThere are three roles in an SSI connection:\n\nInviter: The entity that initiates the connection by sending an invitation.\nInvitee: The entity that receives the invitation and responds with a connection request.\nMediator: An intermediary that facilitates message delivery between entities, especially when one or both parties may not always be online.\n\n\n\n\n\n\n\nNote\n\n\n\nWe will cover mediators in detail later on. For now what you need to understand is that they are used as a service to relay messages between peers, they will store messages and deliver them whenever a peer comes back online, connects to the mediator and fetches their messages.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Connections</span>"
    ]
  },
  {
    "objectID": "section3/connections.html#peerdids",
    "href": "section3/connections.html#peerdids",
    "title": "13  Connections",
    "section": "13.3 PeerDIDs",
    "text": "13.3 PeerDIDs\nThey are a special kind of decentralized identifier with some unique properties that allow them to be perfect for use in order to establish private and secure communications between peers.\nDID Documents such as PrismDIDs are meant to be publicly available and resolvable by arbitrary parties, therefor storing them in a VDR such as Cardano blockchain is an excellent way to achieve this requirement in a reliable way.\nHowever, when Alice and Bob want to interact with each other, only two parties care about the details of that connection: Alice and Bob. Instead of arbitrary parties needing to resolve their DIDs, only Alice and Bob do. Thus, PeerDIDs essentially describe a key-pair to encrypt and sign data to and from Alice and Bob, routed trough their preferred mediators, e.g. When Alice accepts an invite from Bob and they engage the connection protocol, Alice generates a PeerDID that allows her to encrypt and sign data routed trough Bob’s mediator (mediator Y) that only Bob can decrypt, and vice versa, Bob will generate a PeerDID that allows him to encrypt and sign data routed trough Alice’s preferred mediator (mediator X) that only Alice can decrypt.\nThe key benefits of PeerDIDs are:\n\nDecentralized by nature.\nNo transaction cost on blockchain.\nPrivate (only the concerned parties know about them).\nReusable without any reliance on the internet, with no degradation of trust. (adheres to the principles of local-first and offline-first)\n\nLets resolve a PeerDID, we call resolve to the unpacking and parsing of a DID in order to read its content and use the DID for the interactions that we need to achieve. For this example we will resolve a PeerDID from Atala’s mediator sandbox.\ncurl https://sandbox-mediator.atalaprism.io/did\n\ndid:peer:2.Ez6LSghwSE437wnDE1pt3X6hVDUQzSjsHzinpX3XFvMjRAm7y.Vz6Mkhh1e5CEYYq6JBUcTZ6Cp2ranCWRrv7Yax3Le4N59R6dd.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHBzOi8vc2FuZGJveC1tZWRpYXRvci5hdGFsYXByaXNtLmlvIiwiYSI6WyJkaWRjb21tL3YyIl19fQ.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6IndzczovL3NhbmRib3gtbWVkaWF0b3IuYXRhbGFwcmlzbS5pby93cyIsImEiOlsiZGlkY29tbS92MiJdfX0\nWe can see that the mediator returned a PeerDID when we send a GET request to the /did endpoint. In order to resolve this DID we can use an Universal Resolver website for this example:\ncurl https://dev.uniresolver.io/1.0/identifiers/did:peer:2.Ez6LSghwSE437wnDE1pt3X6hVDUQzSjsHzinpX3XFvMjRAm7y.Vz6Mkhh1e5CEYYq6JBUcTZ6Cp2ranCWRrv7Yax3Le4N59R6dd.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHBzOi8vc2FuZGJveC1tZWRpYXRvci5hdGFsYXByaXNtLmlvIiwiYSI6WyJkaWRjb21tL3YyIl19fQ.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6IndzczovL3NhbmRib3gtbWVkaWF0b3IuYXRhbGFwcmlzbS5pby93cyIsImEiOlsiZGlkY29tbS92MiJdfX0\n{\n  \"@context\": \"https://w3id.org/did-resolution/v1\",\n  \"didDocument\": {\n    \"@context\": [\n      \"https://www.w3.org/ns/did/v1\",\n      \"https://w3id.org/security/multikey/v1\",\n      {\n        \"@base\": \"did:peer:2.Ez6LSghwSE437wnDE1pt3X6hVDUQzSjsHzinpX3XFvMjRAm7y.Vz6Mkhh1e5CEYYq6JBUcTZ6Cp2ranCWRrv7Yax3Le4N59R6dd.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHBzOi8vc2FuZGJveC1tZWRpYXRvci5hdGFsYXByaXNtLmlvIiwiYSI6WyJkaWRjb21tL3YyIl19fQ.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6IndzczovL3NhbmRib3gtbWVkaWF0b3IuYXRhbGFwcmlzbS5pby93cyIsImEiOlsiZGlkY29tbS92MiJdfX0\"\n      }\n    ],\n    \"id\": \"did:peer:2.Ez6LSghwSE437wnDE1pt3X6hVDUQzSjsHzinpX3XFvMjRAm7y.Vz6Mkhh1e5CEYYq6JBUcTZ6Cp2ranCWRrv7Yax3Le4N59R6dd.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHBzOi8vc2FuZGJveC1tZWRpYXRvci5hdGFsYXByaXNtLmlvIiwiYSI6WyJkaWRjb21tL3YyIl19fQ.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6IndzczovL3NhbmRib3gtbWVkaWF0b3IuYXRhbGFwcmlzbS5pby93cyIsImEiOlsiZGlkY29tbS92MiJdfX0\",\n    \"verificationMethod\": [\n      {\n        \"id\": \"#key-2\",\n        \"type\": \"Multikey\",\n        \"controller\": \"did:peer:2.Ez6LSghwSE437wnDE1pt3X6hVDUQzSjsHzinpX3XFvMjRAm7y.Vz6Mkhh1e5CEYYq6JBUcTZ6Cp2ranCWRrv7Yax3Le4N59R6dd.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHBzOi8vc2FuZGJveC1tZWRpYXRvci5hdGFsYXByaXNtLmlvIiwiYSI6WyJkaWRjb21tL3YyIl19fQ.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6IndzczovL3NhbmRib3gtbWVkaWF0b3IuYXRhbGFwcmlzbS5pby93cyIsImEiOlsiZGlkY29tbS92MiJdfX0\",\n        \"publicKeyMultibase\": \"z6Mkhh1e5CEYYq6JBUcTZ6Cp2ranCWRrv7Yax3Le4N59R6dd\"\n      },\n      {\n        \"id\": \"#key-1\",\n        \"type\": \"Multikey\",\n        \"controller\": \"did:peer:2.Ez6LSghwSE437wnDE1pt3X6hVDUQzSjsHzinpX3XFvMjRAm7y.Vz6Mkhh1e5CEYYq6JBUcTZ6Cp2ranCWRrv7Yax3Le4N59R6dd.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHBzOi8vc2FuZGJveC1tZWRpYXRvci5hdGFsYXByaXNtLmlvIiwiYSI6WyJkaWRjb21tL3YyIl19fQ.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6IndzczovL3NhbmRib3gtbWVkaWF0b3IuYXRhbGFwcmlzbS5pby93cyIsImEiOlsiZGlkY29tbS92MiJdfX0\",\n        \"publicKeyMultibase\": \"z6LSghwSE437wnDE1pt3X6hVDUQzSjsHzinpX3XFvMjRAm7y\"\n      }\n    ],\n    \"keyAgreement\": [\n      \"#key-1\"\n    ],\n    \"authentication\": [\n      \"#key-2\"\n    ],\n    \"assertionMethod\": [\n      \"#key-2\"\n    ],\n    \"service\": [\n      {\n        \"serviceEndpoint\": {\n          \"uri\": \"https://sandbox-mediator.atalaprism.io\",\n          \"accept\": [\n            \"didcomm/v2\"\n          ]\n        },\n        \"type\": \"DIDCommMessaging\",\n        \"id\": \"#service\"\n      },\n      {\n        \"serviceEndpoint\": {\n          \"uri\": \"wss://sandbox-mediator.atalaprism.io/ws\",\n          \"accept\": [\n            \"didcomm/v2\"\n          ]\n        },\n        \"type\": \"DIDCommMessaging\",\n        \"id\": \"#service-1\"\n      }\n    ]\n  },\n  \"didResolutionMetadata\": {\n    \"contentType\": \"application/did+ld+json\",\n    \"pattern\": \"^(did:peer:.+)$\",\n    \"driverUrl\": \"http://uni-resolver-driver-did-uport:8081/1.0/identifiers/\",\n    \"duration\": 4,\n    \"driverDuration\": 4,\n    \"did\": {\n      \"didString\": \"did:peer:2.Ez6LSghwSE437wnDE1pt3X6hVDUQzSjsHzinpX3XFvMjRAm7y.Vz6Mkhh1e5CEYYq6JBUcTZ6Cp2ranCWRrv7Yax3Le4N59R6dd.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHBzOi8vc2FuZGJveC1tZWRpYXRvci5hdGFsYXByaXNtLmlvIiwiYSI6WyJkaWRjb21tL3YyIl19fQ.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6IndzczovL3NhbmRib3gtbWVkaWF0b3IuYXRhbGFwcmlzbS5pby93cyIsImEiOlsiZGlkY29tbS92MiJdfX0\",\n      \"methodSpecificId\": \"2.Ez6LSghwSE437wnDE1pt3X6hVDUQzSjsHzinpX3XFvMjRAm7y.Vz6Mkhh1e5CEYYq6JBUcTZ6Cp2ranCWRrv7Yax3Le4N59R6dd.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHBzOi8vc2FuZGJveC1tZWRpYXRvci5hdGFsYXByaXNtLmlvIiwiYSI6WyJkaWRjb21tL3YyIl19fQ.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6IndzczovL3NhbmRib3gtbWVkaWF0b3IuYXRhbGFwcmlzbS5pby93cyIsImEiOlsiZGlkY29tbS92MiJdfX0\",\n      \"method\": \"peer\"\n    }\n  },\n  \"didDocumentMetadata\": {}\n}\nThis is what a PeerDID looks like when resolved, please bear in mind that the JSON-LD context for did-resolution and extra didResolutionMetadata entry are added by the resolver and the actual isolated PeerDID is only what we see inside the didDocument payload.\nIn simple terms, a PeerDID is essentially a JSON payload that contains a set of keys and an optional service endpoints, because this is a mediator PeerDID, it contains service endpoints for DIDCommMessaging, in this particular case, you can see it contains two of them, one over regular https and other trough websockets.\nTo go deeper in your understanding of PeerDIDs please refer to the full Peer DID Method Specification. In the Hyperledger Identus ecosystem, only PeerDIDs method 2 are supported at the time of this writing.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Connections</span>"
    ]
  },
  {
    "objectID": "section3/connections.html#out-of-band-invites",
    "href": "section3/connections.html#out-of-band-invites",
    "title": "13  Connections",
    "section": "13.4 Out of Band invites",
    "text": "13.4 Out of Band invites\nOut of Band (OOB) invites are the entry point for some protocols to take place, they usually are encoded in either a JSON payload or a URL and are distributed “out of band”, usually over QR codes, but could be distributed over any medium (Bluetooth, NFC, etc). They gather all required information for one peer to start interacting with another and you can think of them as a way to advertise “coordinates” for anyone that would like to establish an interaction to the inviter.\nFollowing the same example as before, we can see that the sandbox mediator also delivers an OOB invite in a URL form.\nhttps://sandbox-mediator.atalaprism.io?_oob=eyJpZCI6ImExNTY4YzEyLTBjZGMtNDY0Ny05ZGM2LWE1YWFkYTZmODI0NyIsInR5cGUiOiJodHRwczovL2RpZGNvbW0ub3JnL291dC1vZi1iYW5kLzIuMC9pbnZpdGF0aW9uIiwiZnJvbSI6ImRpZDpwZWVyOjIuRXo2TFNnaHdTRTQzN3duREUxcHQzWDZoVkRVUXpTanNIemlucFgzWEZ2TWpSQW03eS5WejZNa2hoMWU1Q0VZWXE2SkJVY1RaNkNwMnJhbkNXUnJ2N1lheDNMZTRONTlSNmRkLlNleUowSWpvaVpHMGlMQ0p6SWpwN0luVnlhU0k2SW1oMGRIQnpPaTh2YzJGdVpHSnZlQzF0WldScFlYUnZjaTVoZEdGc1lYQnlhWE50TG1sdklpd2lZU0k2V3lKa2FXUmpiMjF0TDNZeUlsMTlmUS5TZXlKMElqb2laRzBpTENKeklqcDdJblZ5YVNJNkluZHpjem92TDNOaGJtUmliM2d0YldWa2FXRjBiM0l1WVhSaGJHRndjbWx6YlM1cGJ5OTNjeUlzSW1FaU9sc2laR2xrWTI5dGJTOTJNaUpkZlgwIiwiYm9keSI6eyJnb2FsX2NvZGUiOiJyZXF1ZXN0LW1lZGlhdGUiLCJnb2FsIjoiUmVxdWVzdE1lZGlhdGUiLCJhY2NlcHQiOlsiZGlkY29tbS92MiJdfSwidHlwIjoiYXBwbGljYXRpb24vZGlkY29tbS1wbGFpbitqc29uIn0\nIf we decode the value of the _oob query variable from base64 we get the json payload\n{\n  \"id\" : \"a1568c12-0cdc-4647-9dc6-a5aada6f8247\",\n  \"type\" : \"https://didcomm.org/out-of-band/2.0/invitation\",\n  \"from\" : \"did:peer:2.Ez6LSghwSE437wnDE1pt3X6hVDUQzSjsHzinpX3XFvMjRAm7y.Vz6Mkhh1e5CEYYq6JBUcTZ6Cp2ranCWRrv7Yax3Le4N59R6dd.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHBzOi8vc2FuZGJveC1tZWRpYXRvci5hdGFsYXByaXNtLmlvIiwiYSI6WyJkaWRjb21tL3YyIl19fQ.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6IndzczovL3NhbmRib3gtbWVkaWF0b3IuYXRhbGFwcmlzbS5pby93cyIsImEiOlsiZGlkY29tbS92MiJdfX0\",\n  \"body\" : {\n    \"goal_code\" : \"request-mediate\",\n    \"goal\" : \"RequestMediate\",\n    \"accept\" : [\n      \"didcomm/v2\"\n    ]\n  },\n  \"typ\" : \"application/didcomm-plain+json\"\n}\nAs you can see, an Out of Band invite is really just a way to package a PeerDID and signaling that it can be used for a particular interaction. In this case, for a RequestMediate goal over DIDComm.\nAs a refresher from what we covered, a PeerDID is a way to package a set of keys and optional service endpoints, and so, because this an OOB invite from a mediator, this invite has everything you need (a PeerDID and set of service endpoints) to establish this service as your mediator.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Connections</span>"
    ]
  },
  {
    "objectID": "section3/connections.html#connecting-two-peers",
    "href": "section3/connections.html#connecting-two-peers",
    "title": "13  Connections",
    "section": "13.5 Connecting two peers",
    "text": "13.5 Connecting two peers\nNow, lets issue another kind of Out of Band invite, one from the cloud agent in order to connect.\nThe Cloud Agent can generate Out of Band invites, this invite then can be parsed by another peer (say another Cloud Agent or Edge Client) and use it to establish a connection, the end result should be a DID Peer on both sides that allow them to send messages to each other over DIDComm.\nSo, our first step is to generate the invite:\ncurl --location 'http://127.0.0.1:8080/cloud-agent/connections' \\\n--header 'Content-Type: application/json' \\\n--header 'Accept: application/json' \\\n--data '{\"label\": \"test\"}'\n\n\n\n\n\n\nNote\n\n\n\nThe only parameter we can change when generating an invite is the label, this is optional and it is a simple string that you can use to identify the connection later, a good idea would be to use a uuid that you generate and manage on your systems, or could be an alias or the reason for the connection, this is all contextual to the interaction and use case so in our case we will go with “test”.\n\n\nThe Cloud Agent will respond with a payload that should look like this:\n{\n    \"connectionId\": \"fb36eddd-d51e-42cf-a6fe-e76d2e638b70\",\n    \"thid\": \"fb36eddd-d51e-42cf-a6fe-e76d2e638b70\",\n    \"label\": \"test\",\n    \"role\": \"Inviter\",\n    \"state\": \"InvitationGenerated\",\n    \"invitation\": {\n        \"id\": \"fb36eddd-d51e-42cf-a6fe-e76d2e638b70\",\n        \"type\": \"https://didcomm.org/out-of-band/2.0/invitation\",\n        \"from\": \"did:peer:2.Ez6LSgY6Y67mJ75YCZfZYxYEPQJZs3vaEg2Cc91vppoTA7cpj.Vz6MkpX7H7SNA6ooG5snn2MzgyoRadEZtsjNSL1x7HiiLkqyV.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHA6Ly9ob3N0LmRvY2tlci5pbnRlcm5hbDo4MDgwL2RpZGNvbW0iLCJyIjpbXSwiYSI6WyJkaWRjb21tL3YyIl19fQ\",\n        \"invitationUrl\": \"https://my.domain.com/path?_oob=eyJpZCI6ImZiMzZlZGRkLWQ1MWUtNDJjZi1hNmZlLWU3NmQyZTYzOGI3MCIsInR5cGUiOiJodHRwczovL2RpZGNvbW0ub3JnL291dC1vZi1iYW5kLzIuMC9pbnZpdGF0aW9uIiwiZnJvbSI6ImRpZDpwZWVyOjIuRXo2TFNnWTZZNjdtSjc1WUNaZlpZeFlFUFFKWnMzdmFFZzJDYzkxdnBwb1RBN2Nwai5WejZNa3BYN0g3U05BNm9vRzVzbm4yTXpneW9SYWRFWnRzak5TTDF4N0hpaUxrcXlWLlNleUowSWpvaVpHMGlMQ0p6SWpwN0luVnlhU0k2SW1oMGRIQTZMeTlvYjNOMExtUnZZMnRsY2k1cGJuUmxjbTVoYkRvNE1EZ3dMMlJwWkdOdmJXMGlMQ0p5SWpwYlhTd2lZU0k2V3lKa2FXUmpiMjF0TDNZeUlsMTlmUSIsImJvZHkiOnsiYWNjZXB0IjpbXX19\"\n    },\n    \"createdAt\": \"2025-01-04T12:37:37.059649293Z\",\n    \"metaRetries\": 5,\n    \"self\": \"fb36eddd-d51e-42cf-a6fe-e76d2e638b70\",\n    \"kind\": \"Connection\"\n}\nOnce the connection invite is created you can fetch it’s details by a GETrequest passing the connectionId:\ncurl --location 'http://127.0.0.1:8080/cloud-agent/connections/fb36eddd-d51e-42cf-a6fe-e76d2e638b70' \\\n--header 'Accept: application/json' \\\nYou should get back the same payload as when it was created unless something changed, like the state:\n{\n    \"connectionId\": \"fb36eddd-d51e-42cf-a6fe-e76d2e638b70\",\n    \"thid\": \"fb36eddd-d51e-42cf-a6fe-e76d2e638b70\",\n    \"label\": \"test\",\n    \"role\": \"Inviter\",\n    \"state\": \"InvitationGenerated\",\n    \"invitation\": {\n        \"id\": \"fb36eddd-d51e-42cf-a6fe-e76d2e638b70\",\n        \"type\": \"https://didcomm.org/out-of-band/2.0/invitation\",\n        \"from\": \"did:peer:2.Ez6LSgY6Y67mJ75YCZfZYxYEPQJZs3vaEg2Cc91vppoTA7cpj.Vz6MkpX7H7SNA6ooG5snn2MzgyoRadEZtsjNSL1x7HiiLkqyV.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHA6Ly9ob3N0LmRvY2tlci5pbnRlcm5hbDo4MDgwL2RpZGNvbW0iLCJyIjpbXSwiYSI6WyJkaWRjb21tL3YyIl19fQ\",\n        \"invitationUrl\": \"https://my.domain.com/path?_oob=eyJpZCI6ImZiMzZlZGRkLWQ1MWUtNDJjZi1hNmZlLWU3NmQyZTYzOGI3MCIsInR5cGUiOiJodHRwczovL2RpZGNvbW0ub3JnL291dC1vZi1iYW5kLzIuMC9pbnZpdGF0aW9uIiwiZnJvbSI6ImRpZDpwZWVyOjIuRXo2TFNnWTZZNjdtSjc1WUNaZlpZeFlFUFFKWnMzdmFFZzJDYzkxdnBwb1RBN2Nwai5WejZNa3BYN0g3U05BNm9vRzVzbm4yTXpneW9SYWRFWnRzak5TTDF4N0hpaUxrcXlWLlNleUowSWpvaVpHMGlMQ0p6SWpwN0luVnlhU0k2SW1oMGRIQTZMeTlvYjNOMExtUnZZMnRsY2k1cGJuUmxjbTVoYkRvNE1EZ3dMMlJwWkdOdmJXMGlMQ0p5SWpwYlhTd2lZU0k2V3lKa2FXUmpiMjF0TDNZeUlsMTlmUSIsImJvZHkiOnsiYWNjZXB0IjpbXX19\"\n    },\n    \"createdAt\": \"2025-01-04T12:37:37.059649Z\",\n    \"metaRetries\": 5,\n    \"self\": \"fb36eddd-d51e-42cf-a6fe-e76d2e638b70\",\n    \"kind\": \"Connection\"\n}\nLets dig a bit deeper on what this payload represents.\nThis invite payload contains some important metadata:\n\nconnectionId: The unique identifier of the connection resource, used to fetch the connection details.\nthid: The unique identifier of the thread this connection record belongs to. The value will identical on both sides of the connection (inviter and invitee).\nlabel: A human readable alias for the connection.\nrole: The Cloud Agent role on this connection, either Inviter or Invitee.\nstate: The current status of this connection, note this is contextual to the Cloud Agent role, so as Inviter the states could be: InvitationGenerated, ConnectionRequestReceived, ConnectionResponsePending, ConnectionResponseSent. But is also possible for the Cloud Agent to parse someone else’s invitation, in that case the Cloud Agent will generate a connection with the Invitee role and the possible states for that role are: InvitationReceived, ConnectionRequestPending, ConnectionRequestSent, ConnectionResponseReceived.\ninvitation: The DIDComm invitation details.\ncreatedAt: Date and time when this connection was created or received.\nmetaRetries: The maximum background processing attempts remaining for this record.\nself: The reference to the connection resource.\nkind: The type of object returned. In this case a Connection.\n\nNow lets unpack the invitation details.\n\nid: The unique identifier of the invitation. It should be used as parent thread ID (pthid) for the Connection Request message that follows.\ntype: The DIDComm Message Type URI (MTURI) the invitation message complies with.\nfrom: The DID representing the sender to be used by recipients for future interactions.\ninvitationUrl: The invitation message encoded as a URL.\n\nLets resolve the from DID:\ncurl https://dev.uniresolver.io/1.0/identifiers/did:peer:2.Ez6LSgY6Y67mJ75YCZfZYxYEPQJZs3vaEg2Cc91vppoTA7cpj.Vz6MkpX7H7SNA6ooG5snn2MzgyoRadEZtsjNSL1x7HiiLkqyV.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHA6Ly9ob3N0LmRvY2tlci5pbnRlcm5hbDo4MDgwL2RpZGNvbW0iLCJyIjpbXSwiYSI6WyJkaWRjb21tL3YyIl19fQ\n{\n  \"@context\": \"https://w3id.org/did-resolution/v1\",\n  \"didDocument\": {\n    \"@context\": [\n      \"https://www.w3.org/ns/did/v1\",\n      \"https://w3id.org/security/multikey/v1\",\n      {\n        \"@base\": \"did:peer:2.Ez6LSgY6Y67mJ75YCZfZYxYEPQJZs3vaEg2Cc91vppoTA7cpj.Vz6MkpX7H7SNA6ooG5snn2MzgyoRadEZtsjNSL1x7HiiLkqyV.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHA6Ly9ob3N0LmRvY2tlci5pbnRlcm5hbDo4MDgwL2RpZGNvbW0iLCJyIjpbXSwiYSI6WyJkaWRjb21tL3YyIl19fQ\"\n      }\n    ],\n    \"id\": \"did:peer:2.Ez6LSgY6Y67mJ75YCZfZYxYEPQJZs3vaEg2Cc91vppoTA7cpj.Vz6MkpX7H7SNA6ooG5snn2MzgyoRadEZtsjNSL1x7HiiLkqyV.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHA6Ly9ob3N0LmRvY2tlci5pbnRlcm5hbDo4MDgwL2RpZGNvbW0iLCJyIjpbXSwiYSI6WyJkaWRjb21tL3YyIl19fQ\",\n    \"verificationMethod\": [\n      {\n        \"id\": \"#key-2\",\n        \"type\": \"Multikey\",\n        \"controller\": \"did:peer:2.Ez6LSgY6Y67mJ75YCZfZYxYEPQJZs3vaEg2Cc91vppoTA7cpj.Vz6MkpX7H7SNA6ooG5snn2MzgyoRadEZtsjNSL1x7HiiLkqyV.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHA6Ly9ob3N0LmRvY2tlci5pbnRlcm5hbDo4MDgwL2RpZGNvbW0iLCJyIjpbXSwiYSI6WyJkaWRjb21tL3YyIl19fQ\",\n        \"publicKeyMultibase\": \"z6MkpX7H7SNA6ooG5snn2MzgyoRadEZtsjNSL1x7HiiLkqyV\"\n      },\n      {\n        \"id\": \"#key-1\",\n        \"type\": \"Multikey\",\n        \"controller\": \"did:peer:2.Ez6LSgY6Y67mJ75YCZfZYxYEPQJZs3vaEg2Cc91vppoTA7cpj.Vz6MkpX7H7SNA6ooG5snn2MzgyoRadEZtsjNSL1x7HiiLkqyV.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHA6Ly9ob3N0LmRvY2tlci5pbnRlcm5hbDo4MDgwL2RpZGNvbW0iLCJyIjpbXSwiYSI6WyJkaWRjb21tL3YyIl19fQ\",\n        \"publicKeyMultibase\": \"z6LSgY6Y67mJ75YCZfZYxYEPQJZs3vaEg2Cc91vppoTA7cpj\"\n      }\n    ],\n    \"keyAgreement\": [\n      \"#key-1\"\n    ],\n    \"authentication\": [\n      \"#key-2\"\n    ],\n    \"assertionMethod\": [\n      \"#key-2\"\n    ],\n    \"service\": [\n      {\n        \"serviceEndpoint\": {\n          \"uri\": \"http://host.docker.internal:8080/didcomm\",\n          \"routingKeys\": [],\n          \"accept\": [\n            \"didcomm/v2\"\n          ]\n        },\n        \"type\": \"DIDCommMessaging\",\n        \"id\": \"#service\"\n      }\n    ]\n  },\n  \"didResolutionMetadata\": {\n    \"contentType\": \"application/did+ld+json\",\n    \"pattern\": \"^(did:peer:.+)$\",\n    \"driverUrl\": \"http://uni-resolver-driver-did-uport:8081/1.0/identifiers/\",\n    \"duration\": 3,\n    \"driverDuration\": 3,\n    \"did\": {\n      \"didString\": \"did:peer:2.Ez6LSgY6Y67mJ75YCZfZYxYEPQJZs3vaEg2Cc91vppoTA7cpj.Vz6MkpX7H7SNA6ooG5snn2MzgyoRadEZtsjNSL1x7HiiLkqyV.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHA6Ly9ob3N0LmRvY2tlci5pbnRlcm5hbDo4MDgwL2RpZGNvbW0iLCJyIjpbXSwiYSI6WyJkaWRjb21tL3YyIl19fQ\",\n      \"methodSpecificId\": \"2.Ez6LSgY6Y67mJ75YCZfZYxYEPQJZs3vaEg2Cc91vppoTA7cpj.Vz6MkpX7H7SNA6ooG5snn2MzgyoRadEZtsjNSL1x7HiiLkqyV.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHA6Ly9ob3N0LmRvY2tlci5pbnRlcm5hbDo4MDgwL2RpZGNvbW0iLCJyIjpbXSwiYSI6WyJkaWRjb21tL3YyIl19fQ\",\n      \"method\": \"peer\"\n    }\n  },\n  \"didDocumentMetadata\": {}\n}\nNow this looks familiar, we have the usual set of keys and it looks similar to the mediator DID but in this case we see a serviceEndpoint that contains accepts didcomm/v2 and it’s intended to be used for DIDCommMessaging. What all this means is the Cloud Agent DID is essentially advertising how it will receive DIDComm messages. In other words this could be translated as: “Here is an invite to connect to me, on it you will find a DID that has my public keys and a service endpoint where I receive DIDComm messages”.\nThe final piece to unpack is the invitationUrl, this looks a little odd at first:\n\"https://my.domain.com/path?_oob=eyJpZCI6ImZiMzZlZGRkLWQ1MWUtNDJjZi1hNmZlLWU3NmQyZTYzOGI3MCIsInR5cGUiOiJodHRwczovL2RpZGNvbW0ub3JnL291dC1vZi1iYW5kLzIuMC9pbnZpdGF0aW9uIiwiZnJvbSI6ImRpZDpwZWVyOjIuRXo2TFNnWTZZNjdtSjc1WUNaZlpZeFlFUFFKWnMzdmFFZzJDYzkxdnBwb1RBN2Nwai5WejZNa3BYN0g3U05BNm9vRzVzbm4yTXpneW9SYWRFWnRzak5TTDF4N0hpaUxrcXlWLlNleUowSWpvaVpHMGlMQ0p6SWpwN0luVnlhU0k2SW1oMGRIQTZMeTlvYjNOMExtUnZZMnRsY2k1cGJuUmxjbTVoYkRvNE1EZ3dMMlJwWkdOdmJXMGlMQ0p5SWpwYlhTd2lZU0k2V3lKa2FXUmpiMjF0TDNZeUlsMTlmUSIsImJvZHkiOnsiYWNjZXB0IjpbXX19\"\nThe first thing that looks wrong is the domain, where does my.domain.com comes from? well, it comes from the Cloud Agent and it’s hardcoded, you can’t customize it but it really doesn’t matter, what matters is the payload of the _oob field. The URL is not important as what we really need is inside the base64 encoded field, lets unpack it.\necho 'eyJpZCI6ImZiMzZlZGRkLWQ1MWUtNDJjZi1hNmZlLWU3NmQyZTYzOGI3MCIsInR5cGUiOiJodHRwczovL2RpZGNvbW0ub3JnL291dC1vZi1iYW5kLzIuMC9pbnZpdGF0aW9uIiwiZnJvbSI6ImRpZDpwZWVyOjIuRXo2TFNnWTZZNjdtSjc1WUNaZlpZeFlFUFFKWnMzdmFFZzJDYzkxdnBwb1RBN2Nwai5WejZNa3BYN0g3U05BNm9vRzVzbm4yTXpneW9SYWRFWnRzak5TTDF4N0hpaUxrcXlWLlNleUowSWpvaVpHMGlMQ0p6SWpwN0luVnlhU0k2SW1oMGRIQTZMeTlvYjNOMExtUnZZMnRsY2k1cGJuUmxjbTVoYkRvNE1EZ3dMMlJwWkdOdmJXMGlMQ0p5SWpwYlhTd2lZU0k2V3lKa2FXUmpiMjF0TDNZeUlsMTlmUSIsImJvZHkiOnsiYWNjZXB0IjpbXX19' | base64 -d\n{\n  \"id\": \"fb36eddd-d51e-42cf-a6fe-e76d2e638b70\",\n  \"type\": \"https://didcomm.org/out-of-band/2.0/invitation\",\n  \"from\": \"did:peer:2.Ez6LSgY6Y67mJ75YCZfZYxYEPQJZs3vaEg2Cc91vppoTA7cpj.Vz6MkpX7H7SNA6ooG5snn2MzgyoRadEZtsjNSL1x7HiiLkqyV.SeyJ0IjoiZG0iLCJzIjp7InVyaSI6Imh0dHA6Ly9ob3N0LmRvY2tlci5pbnRlcm5hbDo4MDgwL2RpZGNvbW0iLCJyIjpbXSwiYSI6WyJkaWRjb21tL3YyIl19fQ\",\n  \"body\": {\n    \"accept\": []\n  }\n}\nAnd there it is, the _oob encoded payload contains the bare minimum to tell you it’s a DIDComm invitation from a DID Peer.\nTODO: Create invite on cloud agent, connect sample SDK code. (Milestone 4)\nTODO Checklist\n\nConcept of Connections\nExplain PeerDIDs\nHow connections are achieved trough PeerDIDs\nOut of Band invites\nHow to Connect two peers\nDIDless connection (Atala Roadmap)",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Connections</span>"
    ]
  },
  {
    "objectID": "section3/verifiable-credentials.html",
    "href": "section3/verifiable-credentials.html",
    "title": "14  Verifiable Credentials",
    "section": "",
    "text": "14.1 Overview\nVerifiable Credentials are an integral part of Self-Sovereign Identity, allowing individuals to keep and control how their personal information is shared.\nA Verifiable Credential (VC) is a digital statement made by an Issuer about a Subject. This statement is cryptographically secured and can be verified by a third party without the need for the Verifier to directly contact the Issuer. Verifiable Credentials are used to represent information such as identity documents, academic records, professional certifications, and other forms of credentials that traditionally exist in paper form. Coupled with other technology such as Self-Sovereign Identity, Verifiable Credentials can unlock novel and exciting use cases.\nComponents of a Verifiable Credential:\nHow Verifiable Credentials Work:\nBenefits of Verifiable Credentials:\nUse Cases:",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Verifiable Credentials</span>"
    ]
  },
  {
    "objectID": "section3/verifiable-credentials.html#overview",
    "href": "section3/verifiable-credentials.html#overview",
    "title": "14  Verifiable Credentials",
    "section": "",
    "text": "Issuer: The entity that creates and signs the credential. This could be an organization, institution, government entity or individual.\nHolder: The entity or individual to whom the credential is issued to and who can present proof to a Verifier.\nVerifier: The entity or individual that checks the authenticity and validity of the credential trough requesting proof from a Holder.\nSubject: The entity or individual about which the claims are made. In many cases, the Holder and the Subject are the same entity.\nClaims: Statements about the Subject, such as “Alice has an Educational Credential from Vienna University.”\nProof: Cryptographic evidence, using Digital Signatures, that the credential is authentic and has not been tampered with.\nMetadata: Additional contextual information which may have content or application specific meaning, like expiration date or credential description.\n\n\n\nIssuance: The issuer creates a credential containing claims about the subject, the subject DID (public key) and signs it with their private key.\nStorage: The holder receives the credential and stores it in a digital wallet.\nPresentation: When required, the holder presents the credential to a verifier. Selective Disclosure can be used to reveal only relevant context about a claim, and not all user data.\nVerification: The verifier checks the credential’s authenticity by validating the issuer’s digital signature and ensuring the credential has not been tampered with.\n\n\n\nInteroperability: VCs follow standard formats, making them compatible across different systems and platforms.\nPrivacy: Holders can share only the necessary information, protecting their privacy.\nSecurity: Cryptographic techniques ensure the integrity and authenticity of credentials.\nDecentralization: VCs do not rely on a central authority for verification, reducing single points of failure.\n\n\n\nDigital Identity: Proof of identity for accessing services.\nEducation: Digital diplomas and certificates.\nHealthcare: Vaccination records and medical certificates.\nEmployment: Professional qualifications and work experience.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Verifiable Credentials</span>"
    ]
  },
  {
    "objectID": "section3/verifiable-credentials.html#formats",
    "href": "section3/verifiable-credentials.html#formats",
    "title": "14  Verifiable Credentials",
    "section": "14.2 Formats",
    "text": "14.2 Formats\nThere are several formats for Verifiable Credentials, including:\n\nW3C - v1.1\nW3C - v2.0 (Atala Roadmap)\nSD-JWT VC - Active Internet-Draft\nOID4VCI (Atala Roadmap?)\nAnonCreds",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Verifiable Credentials</span>"
    ]
  },
  {
    "objectID": "section3/verifiable-credentials.html#schemas",
    "href": "section3/verifiable-credentials.html#schemas",
    "title": "14  Verifiable Credentials",
    "section": "14.3 Schemas",
    "text": "14.3 Schemas\nIssuing a Verifiable Credential (VC) requires a credential schema, which serves as a general template defining the valid claims (attributes) the VC can contain. This schema acts as a reference point to ensure that the VC is correctly formatted and valid by checking its claims against the predefined structure.\nSchemas can optionally be published on a Verifiable Data Registry (VDR), which is particularly beneficial for widely applicable schema types. Publishing schemas on a VDR facilitates their adoption by other parties, enabling third parties to issue VCs that conform to the same standardized credential format.\nFor example, relevant entities or industry consortiums can collaboratively develop, agree upon, and publish schemas that they will adopt and recognize. This approach encourages other players in the ecosystem to adopt these schemas as well, fostering interoperability and growth within the ecosystem.\nBy standardizing schemas, the VC ecosystem becomes more cohesive and efficient, allowing for easier verification and broader acceptance of credentials across different platforms and organizations.\nExample Credential Schema\n{\n  \"$id\": \"https://example.com/driving-license-1.0\",\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"description\": \"Driving License\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"emailAddress\": {\n      \"type\": \"string\",\n      \"format\": \"email\"\n    },\n    \"givenName\": {\n      \"type\": \"string\"\n    },\n    \"familyName\": {\n      \"type\": \"string\"\n    },\n    \"dateOfIssuance\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"drivingLicenseID\": {\n      \"type\": \"string\"\n    },\n    \"drivingClass\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"emailAddress\",\n    \"familyName\",\n    \"dateOfIssuance\",\n    \"drivingLicenseID\",\n    \"drivingClass\"\n  ],\n  \"additionalProperties\": true\n}\n\nPublishing your Schema (Milestone 3)",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Verifiable Credentials</span>"
    ]
  },
  {
    "objectID": "section3/verifiable-credentials.html#issuing",
    "href": "section3/verifiable-credentials.html#issuing",
    "title": "14  Verifiable Credentials",
    "section": "14.4 Issuing",
    "text": "14.4 Issuing\nIssuing a Verifiable Credential (VC) is a multi-step process that occurs between an issuer agent and a holder. Currently, this process is only supported through the cloud agent’s API endpoints, as there is no functionality to issue VCs from edge client SDKs.\nThe issuing process shares a common prerequisite across all three supported VC formats (JWT, SD-JWT, and AnonCreds): an established connection between the issuing cloud agent and a holder. The holder can be either another cloud agent or an edge client device.\nAdditional requirements vary depending on the VC format:\n\nFor JWT and SD-JWT:\n\nThe issuing agent must have a published DID Prism.\n\nFor SD-JWT only:\n\nThe holder must also have a DID Prism, but it doesn’t need to be published on-chain.\n\nFor AnonCreds:\n\nNo additional requirements beyond the established connection.\n\n\n\n14.4.1 Issuer flow\nFrom the issuer perspective this is the regular flow to issue a VC:\n\nCreate a credential offer over API endpoint\nSend the credential offer to holder over DIDCOMM\nReceive credential request from holder over DIDCOMM\nIssue and process credential\nSend credential to holder over DIDCOMM\n\nDepending on the value of automaticIssuance the credential will be automatically issued on step 4 as soon as the credential request is received from the holder, if automaticIssuance is set to false, the issuer must manually trigger issuance and process trough an API call.\n\n\n14.4.2 Holder flow\nFrom the holder perspective this is regular flow to receive a VC:\n\nReceived offer over DIDCOMM\nAccept offer, in this step the SDK calls cloud agent API endpoint to trigger the issuance of the VC\nReceive credential over DIDCOMM\n\nTODO: Add code / API calls on Milestone 3.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Verifiable Credentials</span>"
    ]
  },
  {
    "objectID": "section3/verifiable-credentials.html#revoking",
    "href": "section3/verifiable-credentials.html#revoking",
    "title": "14  Verifiable Credentials",
    "section": "14.5 Revoking",
    "text": "14.5 Revoking\nRevoking a VC is done through a simple API call to the cloud agent to revoke a specific credential by it’s ID. The end result is that any presentation proof request will fail if the VC has been revoked.\nTODO: Add code / API calls on Milestone 3.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Verifiable Credentials</span>"
    ]
  },
  {
    "objectID": "section3/didcomm.html",
    "href": "section3/didcomm.html",
    "title": "15  DIDComm",
    "section": "",
    "text": "15.1 Overview\nDIDComm v2 (Decentralized Identifier Communication version 2) is a set of communication protocols designed to enable secure, private, and interoperable messaging between DIDs. These protocols have been adopted throughout Identus to standardize many important interactions, like sending and receiving encrypted messages between a mediator its peers.\nDIDComm Messaging messages are encrypted JSON Web Message (JWM) envelopes. They have a standard structure including headers, a body, and optional attachments, which are encrypted and signed to ensure security and integrity.\nFor details on how messages are sent and received in Identus, see Mediators",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>DIDComm</span>"
    ]
  },
  {
    "objectID": "section3/didcomm.html#sending-messages",
    "href": "section3/didcomm.html#sending-messages",
    "title": "15  DIDComm",
    "section": "15.2 Sending Messages",
    "text": "15.2 Sending Messages",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>DIDComm</span>"
    ]
  },
  {
    "objectID": "section3/didcomm.html#sending-files",
    "href": "section3/didcomm.html#sending-files",
    "title": "15  DIDComm",
    "section": "15.3 Sending Files",
    "text": "15.3 Sending Files",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>DIDComm</span>"
    ]
  },
  {
    "objectID": "section3/verification.html",
    "href": "section3/verification.html",
    "title": "16  Verification",
    "section": "",
    "text": "16.1 Presenting proof\nVerification is a crucial interaction between Self-Sovereign Identity (SSI) agents. This process involves a verifier creating a present proof request to a holder, who then responds with a proof presentation. The verifier agent subsequently verifies this presentation.\nThe verification process consists of several key steps:\nIt’s important to note that a valid and correctly formatted VC alone is insufficient for acceptance. While the verifier agent automatically checks the cryptography, the verifier must also:\nThus, the verifier has the final say in accepting or rejecting the verified proof presentation.\nThe core of the verification process involves the holder signing a random challenge along with the presentation. The verifier agent extracts the public key from this signature and compares it with the public key of the VC’s subject. If these public keys match, it confirms that the entity responding to the proof presentation request has access to the private key of the VC’s subject.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Verification</span>"
    ]
  },
  {
    "objectID": "section3/verification.html#presenting-proof",
    "href": "section3/verification.html#presenting-proof",
    "title": "16  Verification",
    "section": "",
    "text": "The verifier initiates a present proof request.\nThe holder responds with a proof presentation.\nThe verifier agent automatically verifies the presentation’s cryptographic integrity.\nThe verifier makes a final decision to accept or reject the Verifiable Credential (VC).\n\n\n\nConfirm the trustworthiness of the issuer.\nEvaluate and accept the claims within the VC.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Verification</span>"
    ]
  },
  {
    "objectID": "section3/verification.html#presentation-policies",
    "href": "section3/verification.html#presentation-policies",
    "title": "16  Verification",
    "section": "16.2 Presentation policies",
    "text": "16.2 Presentation policies\nTo streamline the verification process, verifier cloud agents can implement presentation policies. These policies serve as an automated mechanism to enhance efficiency and consistency in verifying Verifiable Credentials (VCs).\nKey aspects of presentation policies include:\n\nTrusted Issuer Lists:\n\nPolicies establish sets of trusted issuers for specific VC schemas.\nThis allows verifiers to pre-approve credible sources for particular types of credentials.\n\nDynamic Management:\n\nPolicies can be updated and managed over time.\nVerifiers can add or remove trusted issuers as needed, adapting to changes in the ecosystem or their own requirements.\n\nAutomated Rejection:\n\nThe verifier cloud agent can automatically reject a presentation proof if the issuer is not listed in the relevant presentation policy.\nThis reduces manual intervention and speeds up the verification process for non-compliant credentials.\n\nSchema-Specific Trust:\n\nPolicies are tied to specific VC schemas, allowing for granular control over which issuers are trusted for different types of credentials.\n\n\nBy implementing presentation policies, verifiers can significantly reduce the manual effort required in the verification process, while maintaining control over which issuers they deem trustworthy for different types of credentials. This approach balances automation with the flexibility to adapt to changing trust relationships in the Self-Sovereign Identity ecosystem.",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Verification</span>"
    ]
  },
  {
    "objectID": "section3/verification.html#selective-disclosure",
    "href": "section3/verification.html#selective-disclosure",
    "title": "16  Verification",
    "section": "16.3 Selective disclosure",
    "text": "16.3 Selective disclosure\nStandard Verifiable Credentials (VCs) presented in JWT format require holders to disclose all content for verifiers to validate integrity and confirm authenticity. However, this approach can compromise privacy when verifiers only need to check specific claims.\nConsider a common scenario: age verification at a bar. While establishments typically only need to confirm if a customer is of legal drinking age (18 or 21 in many jurisdictions), traditional ID checks reveal excessive personal information, including full name, address, and exact date of birth. This over-disclosure becomes particularly problematic in digital interactions, where shared information can be easily copied and archived across the internet.\nTo address this privacy concern, the concept of selective disclosure was developed. This approach utilizes zero knowledge proofs, a cryptographic technique allowing the sharing of specific information subsets without revealing the entire content.\nHyperledger Identus currently supports two VC formats that enable selective disclosure proofs:\n\nSD-JWT (Selective Disclosure JSON Web Token)\nAnonCreds (Anonymous Credentials)\n\nThese formats allow holders to prove specific claims (e.g., being over 21) without disclosing unnecessary personal details, striking a balance between verification needs and privacy protection.\nSome of the benefits of Selective Disclosure include:\n\nEnhanced Privacy: Minimizes the exposure of sensitive personal information.\nCompliance: Aligns with data protection regulations by adhering to data minimization principles.\nUser Control: Empowers individuals to manage their digital identity more effectively.\nReduced Risk: Limits the potential for data breaches or misuse of personal information.\n\nTODO: Add API request and code examples (Milestone 3)",
    "crumbs": [
      "Section III - Building",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Verification</span>"
    ]
  },
  {
    "objectID": "section4/installation-production.html",
    "href": "section4/installation-production.html",
    "title": "17  Installation - Production Environment",
    "section": "",
    "text": "17.1 Overview\nA production environment setup requires connecting Hyperledger Identus to the Cardano blockchain as the Verifiable Data Registry (VDR). This is achieved through the prism-node component, which abstracts the VDR operations for publishing, resolving, updating, and deactivating Decentralized Identifiers (DIDs).\nAccording to the official documentation:\nWhile our local setup instructs prism-node to use a local database as the VDR for testing and development, it lacks the benefits of Cardano’s secure and decentralized blockchain for publishing DIDs on-chain. To reach the blockchain, our prism-node needs to connect to two components:\nWhen the cloud agent needs to publish, update, or deactivate DIDs, it requests prism-node to create and validate a transaction, which is then passed to the cardano-wallet for submission to the blockchain. Simultaneously, prism-node connects to cardano-db-sync to read new blocks, filter DID Prisms published on-chain, and notify the cloud agent when the DID operation reaches a certain number of confirmations.\nProduction and pre-production installations are similar, with the main difference being that production points to mainnet and pre-production to testnet for both cardano-wallet and cardano-db-sync. This is achieved by changing environmental variables passed to the Docker containers.\nFor a production setup, we recommend additional security measures, including changing default passwords, deactivating unnecessary services, and setting up managed database and secret storage providers with regular backups. While these aspects are beyond the scope of this book, we will provide corresponding notes with our recommendations when appropriate.",
    "crumbs": [
      "Section IV - Deploy",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Installation - Production Environment</span>"
    ]
  },
  {
    "objectID": "section4/installation-production.html#overview",
    "href": "section4/installation-production.html#overview",
    "title": "17  Installation - Production Environment",
    "section": "",
    "text": "The PRISM Node generates a transaction with information about the DID operation and verifies and validates the DID operation before publishing it to the blockchain. Once the transaction gets confirmed on the blockchain, the PRISM Node updates its internal state to reflect the changes.\n\n\n\nA full node Cardano wallet to submit transactions to the blockchain\nCardano-DB-Sync to read the blockchain through a normalized database interface",
    "crumbs": [
      "Section IV - Deploy",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Installation - Production Environment</span>"
    ]
  },
  {
    "objectID": "section4/installation-production.html#hardware-recommendations",
    "href": "section4/installation-production.html#hardware-recommendations",
    "title": "17  Installation - Production Environment",
    "section": "17.2 Hardware recommendations",
    "text": "17.2 Hardware recommendations\nThe Hyperledger Identus cloud agent alone doesn’t require too much hardware, any instance with 2GB-4GB ram will run it for testing purposes. Of course as you scale in usage you will naturally want more ram available to handle higher concurrent loads.\nThe Cardano wallet and DB sync components on the other hand are going to need a lot more resources due to the mainnet requirements, according to the official documentation, to run a full Cardano node you need:\n\n200GB of disk space (for the history of blocks)\n24GB of RAM (for the current UTxO set)\n\nOf course, on a production environment you may want to run your agent, wallet and db-sync on different machines connected through a VPN or SSH tunnel in order to isolate them and improve security, e.g., your Cardano wallet may be only connecting to a Cardano node, but not exposed to the Internet. You may also reuse and share your Cardano node instance for your wallet and db-sync components, reducing your hardware requirements.\nThere are many ways to setup your infrastructure and at least in the beginning, the Cardano node is the most resource demanding of all components.",
    "crumbs": [
      "Section IV - Deploy",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Installation - Production Environment</span>"
    ]
  },
  {
    "objectID": "section4/installation-production.html#configuration",
    "href": "section4/installation-production.html#configuration",
    "title": "17  Installation - Production Environment",
    "section": "17.3 Configuration",
    "text": "17.3 Configuration\nIn order to setup preprod we recommend copying the config files from the Identus cloud agent and making your own modifications. This is because we will need to modify the docker compose file and that is currently shared among every other type of install such as local, dev and multi. So, to avoid making modifications that will conflict with those defaults, we recommend copying and merging the config into it’s own file.\n\n17.3.1 Preparing base config files\n\nCopy infrastructure/local config into your preprod destination, e.g. standing in the cloud-agent root directory:\n\ncp -rf infrastructure/local infrastructure/preprod\n\nCopy infrastructure/shared/docker-compose.yml for preprod:\n\ncp infrastructure/shared/docker-compose.yml infrastructure/shared/docker-compose-preprod.yml\n\nModify infrastructure/preprod/run.sh to point to the new docker compose, the diff between the files should look like this:\n\n--- local/run.sh    2024-06-18 13:08:47\n+++ preprod/run.sh  2024-09-16 17:03:56\n@@ -125,5 +125,5 @@\n\n PORT=${PORT} NETWORK=${NETWORK} DOCKERHOST=${DOCKERHOST} docker compose \\\n    -p ${NAME} \\\n-   -f ${SCRIPT_DIR}/../shared/docker-compose.yml \\\n+   -f ${SCRIPT_DIR}/../shared/docker-compose-preprod.yml \\\n    --env-file ${ENV_FILE} ${DEBUG} up ${BACKGROUND} ${WAIT}\n\nModify docker-compse-prepod.yml to disable postgres port mapping and to be able to set DEV_MODE trough an environment variable:\n\n--- docker-compose.yml  2024-06-18 13:08:47\n+++ docker-compose-preprod.yml  2024-09-16 17:41:36\n@@ -15,8 +15,8 @@\n       - pg_data_db:/var/lib/postgresql/data\n       - ./postgres/init-script.sh:/docker-entrypoint-initdb.d/init-script.sh\n       - ./postgres/max_conns.sql:/docker-entrypoint-initdb.d/max_conns.sql\n-    ports:\n-      - \"127.0.0.1:${PG_PORT:-5432}:5432\"\n+    #ports:\n+    #  - \"127.0.0.1:${PG_PORT:-5432}:5432\"\n     healthcheck:\n       test: [\"CMD\", \"pg_isready\", \"-U\", \"postgres\", \"-d\", \"agent\"]\n       interval: 10s\n@@ -96,7 +96,7 @@\n       VAULT_ADDR: ${VAULT_ADDR:-http://vault-server:8200}\n       VAULT_TOKEN: ${VAULT_DEV_ROOT_TOKEN_ID:-root}\n       SECRET_STORAGE_BACKEND: postgres\n-      DEV_MODE: true\n+      DEV_MODE: ${DEV_MODE:-true}\n       DEFAULT_WALLET_ENABLED:\n       DEFAULT_WALLET_SEED:\n       DEFAULT_WALLET_WEBHOOK_URL:\n\nModify .env file and add environmental variables for Cardano, please note that NETWORK variable conflicts with the prism node network, so we are renaming it to NODE_CARDANO_NETWORK, your .env should look like this:\n\n### IDENTUS\nAGENT_VERSION=1.33.0\nPRISM_NODE_VERSION=2.2.1\nVAULT_DEV_ROOT_TOKEN_ID=root\n\n### CARDANO\nNODE_CARDANO_NETWORK=preprod\nNODE_DB=$PWD/cardano/node-db\nWALLET_DB=$PWD/cardano/wallet-db\nNODE_CONFIGS=$PWD/cardano/configs\nNODE_SOCKET_NAME=node.socket\nNODE_SOCKET_DIR=$PWD/cardano/ipc\nNODE_TAG=9.1.1\nWALLET_TAG=2024.9.3\nWALLET_PORT=8090\nWALLET_UI_PORT=8091\n\nUpdate your docker-composer-preprod.yml to add the Cardano wallet service.\n\n---\nversion: \"3.8\"\n\nservices:\n  ##########################\n  # Database\n  ##########################\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_MULTIPLE_DATABASES: \"pollux,connect,agent,node_db\"\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: postgres\n    volumes:\n      - pg_data_db:/var/lib/postgresql/data\n      - ./postgres/init-script.sh:/docker-entrypoint-initdb.d/init-script.sh\n      - ./postgres/max_conns.sql:/docker-entrypoint-initdb.d/max_conns.sql\n    #ports:\n    #  - \"127.0.0.1:${PG_PORT:-5432}:5432\"\n    healthcheck:\n      test: [\"CMD\", \"pg_isready\", \"-U\", \"postgres\", \"-d\", \"agent\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  pgadmin:\n    image: dpage/pgadmin4\n    environment:\n      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL:-pgadmin4@pgadmin.org}\n      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD:-admin}\n      PGADMIN_CONFIG_SERVER_MODE: \"False\"\n    volumes:\n      - pgadmin:/var/lib/pgadmin\n    ports:\n      - \"127.0.0.1:${PGADMIN_PORT:-5050}:80\"\n    depends_on:\n      db:\n        condition: service_healthy\n    profiles:\n      - debug\n\n  ##########################\n  # Services\n  ##########################\n\n  prism-node:\n    image: ghcr.io/input-output-hk/prism-node:${PRISM_NODE_VERSION}\n    environment:\n      NODE_PSQL_HOST: db:5432\n      NODE_REFRESH_AND_SUBMIT_PERIOD:\n      NODE_MOVE_SCHEDULED_TO_PENDING_PERIOD:\n      NODE_WALLET_MAX_TPS:\n    depends_on:\n      db:\n        condition: service_healthy\n\n  vault-server:\n    image: hashicorp/vault:latest\n    #    ports:\n    #      - \"8200:8200\"\n    environment:\n      VAULT_ADDR: \"http://0.0.0.0:8200\"\n      VAULT_DEV_ROOT_TOKEN_ID: ${VAULT_DEV_ROOT_TOKEN_ID}\n    command: server -dev -dev-root-token-id=${VAULT_DEV_ROOT_TOKEN_ID}\n    cap_add:\n      - IPC_LOCK\n    healthcheck:\n      test: [\"CMD\", \"vault\", \"status\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  cloud-agent:\n    image: ghcr.io/hyperledger/identus-cloud-agent:${AGENT_VERSION}\n    environment:\n      POLLUX_DB_HOST: db\n      POLLUX_DB_PORT: 5432\n      POLLUX_DB_NAME: pollux\n      POLLUX_DB_USER: postgres\n      POLLUX_DB_PASSWORD: postgres\n      CONNECT_DB_HOST: db\n      CONNECT_DB_PORT: 5432\n      CONNECT_DB_NAME: connect\n      CONNECT_DB_USER: postgres\n      CONNECT_DB_PASSWORD: postgres\n      AGENT_DB_HOST: db\n      AGENT_DB_PORT: 5432\n      AGENT_DB_NAME: agent\n      AGENT_DB_USER: postgres\n      AGENT_DB_PASSWORD: postgres\n      POLLUX_STATUS_LIST_REGISTRY_PUBLIC_URL: http://${DOCKERHOST}:${PORT}/cloud-agent\n      DIDCOMM_SERVICE_URL: http://${DOCKERHOST}:${PORT}/didcomm\n      REST_SERVICE_URL: http://${DOCKERHOST}:${PORT}/cloud-agent\n      PRISM_NODE_HOST: prism-node\n      PRISM_NODE_PORT: 50053\n      VAULT_ADDR: ${VAULT_ADDR:-http://vault-server:8200}\n      VAULT_TOKEN: ${VAULT_DEV_ROOT_TOKEN_ID:-root}\n      SECRET_STORAGE_BACKEND: postgres\n      DEV_MODE: ${DEV_MODE:-true}\n      DEFAULT_WALLET_ENABLED:\n      DEFAULT_WALLET_SEED:\n      DEFAULT_WALLET_WEBHOOK_URL:\n      DEFAULT_WALLET_WEBHOOK_API_KEY:\n      DEFAULT_WALLET_AUTH_API_KEY:\n      GLOBAL_WEBHOOK_URL:\n      GLOBAL_WEBHOOK_API_KEY:\n      WEBHOOK_PARALLELISM:\n      ADMIN_TOKEN:\n      API_KEY_SALT:\n      API_KEY_ENABLED:\n      API_KEY_AUTHENTICATE_AS_DEFAULT_USER:\n      API_KEY_AUTO_PROVISIONING:\n    depends_on:\n      db:\n        condition: service_healthy\n      prism-node:\n        condition: service_started\n      vault-server:\n        condition: service_healthy\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://cloud-agent:8085/_system/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 5\n    extra_hosts:\n      - \"host.docker.internal:host-gateway\"\n\n  swagger-ui:\n    image: swaggerapi/swagger-ui:v5.1.0\n    environment:\n      - 'URLS=[\n        { name: \"Cloud Agent\", url: \"/docs/cloud-agent/api/docs.yaml\" }\n        ]'\n\n  apisix:\n    image: apache/apisix:2.15.0-alpine\n    volumes:\n      - ./apisix/conf/apisix.yaml:/usr/local/apisix/conf/apisix.yaml:ro\n      - ./apisix/conf/config.yaml:/usr/local/apisix/conf/config.yaml:ro\n    ports:\n      - \"${PORT}:9080/tcp\"\n    depends_on:\n      - cloud-agent\n      - swagger-ui\n\n  ##########################\n  # Cardano\n  ##########################\n\n  cardano-node:\n    image: cardanofoundation/cardano-wallet:${WALLET_TAG}\n    environment:\n      CARDANO_NODE_SOCKET_PATH: /ipc/${NODE_SOCKET_NAME}\n    volumes:\n      - ${NODE_DB}:/data\n      - ${NODE_SOCKET_DIR}:/ipc\n      - ${NODE_CONFIGS}:/configs\n    restart: on-failure\n    #user: ${USER_ID}:${GROUP_ID}\n    logging:\n      driver: \"json-file\"\n      options:\n        compress: \"true\"\n        max-file: \"10\"\n        max-size: \"50m\"\n    entrypoint: []\n    command: &gt;\n      cardano-node run --topology /configs/cardano/${NODE_CARDANO_NETWORK}/topology.json\n        --database-path /data\n        --socket-path /ipc/node.socket\n        --config /configs/cardano/${NODE_CARDANO_NETWORK}/config.json\n        +RTS -N -A16m -qg -qb -RTS\n\n  cardano-wallet:\n    image: cardanofoundation/cardano-wallet:${WALLET_TAG}\n    volumes:\n      - ${WALLET_DB}:/wallet-db\n      - ${NODE_SOCKET_DIR}:/ipc\n      - ${NODE_CONFIGS}:/configs\n    ports:\n      - 127.0.0.1:${WALLET_PORT}:8090\n      - 127.0.0.1:${WALLET_UI_PORT}:8091\n    environment:\n      NETWORK: ${NODE_CARDANO_NETWORK}\n    entrypoint: []\n    command: &gt;\n      cardano-wallet serve\n        --node-socket /ipc/${NODE_SOCKET_NAME}\n        --database /wallet-db\n        --listen-address 0.0.0.0\n        --testnet /configs/cardano/${NODE_CARDANO_NETWORK}/byron-genesis.json\n\n    #user: ${USER_ID}:${GROUP_ID}\n    restart: on-failure\n    logging:\n      driver: \"json-file\"\n      options:\n        compress: \"true\"\n        max-file: \"10\"\n        max-size: \"50m\"\n  icarus:\n    image: piotrstachyra/icarus:v2023-04-14\n    ports:\n      - 127.0.0.1:4444:4444\n    network_mode: \"host\"\n    restart: on-failure\n\nvolumes:\n  pg_data_db:\n  pgadmin:\n  node-ipc:\n# Temporary commit network setting due to e2e CI bug\n# to be enabled later after debugging\n#networks:\n#  default:\n#    name: ${NETWORK}\n\n\n17.3.2 Cardano wallet\nIn order to publish DIDs into the VDR, we need to setup our Cardano wallet, the following steps will incorporate the Cardano wallet docker config into our Identus docker config. We will merge whats on https://github.com/cardano-foundation/cardano-wallet/tree/master/run/preprod/docker into our cloud agent setup.\n\nCreate snapshot.sh\n\n#! /usr/bin/env -S nix shell 'nixpkgs#curl' 'nixpkgs#lz4' 'nixpkgs#gnutar' --command bash\n# shellcheck shell=bash\n\nset -euo pipefail\n\n# shellcheck disable=SC1091\nsource .env\n\n# Define a local db if NODE_DB is not set\nif [[ -z \"${NODE_DB-}\" ]]; then\n    LOCAL_NODE_DB=./databases/node-db\n    mkdir -p $LOCAL_NODE_DB\n    NODE_DB=$LOCAL_NODE_DB\nfi\n\n# Clean the db directory\nrm -rf \"${NODE_DB:?}\"/*\n\necho \"Network: $NETWORK\"\n\ncase \"$NETWORK\" in\n    preprod)\n        SNAPSHOT_NAME=$(curl -s https://downloads.csnapshots.io/testnet/testnet-db-snapshot.json| jq -r .[].file_name )\n        echo \"Snapshot name: $SNAPSHOT_NAME\"\n        SNAPSHOT_URL=\"https://downloads.csnapshots.io/testnet/$SNAPSHOT_NAME\"\n        ;;\n    mainnet)\n        SNAPSHOT_NAME=$(curl -s https://downloads.csnapshots.io/mainnet/mainnet-db-snapshot.json| jq -r .[].file_name )\n        echo \"Snapshot name: $SNAPSHOT_NAME\"\n        SNAPSHOT_URL=\"https://downloads.csnapshots.io/mainnet/$SNAPSHOT_NAME\"\n        ;;\n    *)\n        echo \"Error: Invalid network $NETWORK\"\n        exit 1\n        ;;\nesac\n\necho \"Downloading the snapshot...\"\n\nif [ -n \"${LINK_TEST:-}\" ]; then\n    echo \"Link test enabled\"\n    echo \"Snapshot URL: $SNAPSHOT_URL\"\n    curl -f -LI \"$SNAPSHOT_URL\" &gt; /dev/null\n    curl -r 0-1000000 -SL \"$SNAPSHOT_URL\" &gt; /dev/null\n    exit 0\nfi\n\ncurl -SL \"$SNAPSHOT_URL\" | lz4 -c -d - | tar -x -C \"$NODE_DB\"\n\nmv -f \"$NODE_DB\"/db/* \"$NODE_DB\"/\nrm -rf \"$NODE_DB\"/db\n\necho \"Snapshot downloaded and extracted to $NODE_DB\"\n\nRun snapshot.sh in order to sync the required ledger snapshot (you will need curl, lz4 and tar installed in your system):\n\nbash snapshot.sh\nNetwork: preprod\nSnapshot name: testnet-db-70689600.tar.lz4\nDownloading the snapshot...\n...\nSnapshot downloaded and extracted to ./cardano/node-db\n\nCopy Cardano wallet configs into ./cardano/configs\nRun ./refresh.sh to download the configs.\nConfirm configs directory for preprod look like this:\n\nls cardano/configs/cardano/preprod\nalonzo-genesis.json  byron-genesis.json   config.json          conway-genesis.json  download.sh          shelley-genesis.json topology.json\nIn this chapter we will discuss how to prepare a production envioronment for an Identus application.\nWe will discuss:\n\nHardware recommendations\nProduction configuration and security\nLock down Docker / Postgres (default password hole, etc)\nSSL\nMulti Tenancy\nKeycloak\nTestnet / Preprod env\nConnecting to Mainnet\nSet up Cardano Wallet\nKey Management with HashiCorp\nConnecting to Cardano\nRunning dbSync",
    "crumbs": [
      "Section IV - Deploy",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Installation - Production Environment</span>"
    ]
  },
  {
    "objectID": "section4/mediator.html",
    "href": "section4/mediator.html",
    "title": "18  Mediator",
    "section": "",
    "text": "18.1 Overview\nA Self-Sovereign Identity Mediator is a service that enables private and secure connections between peers. Its primary function is to relay encrypted messages between DIDs using DIDComm V2 protocols. Since each participant wallet is Self-Sovereign, Mediators help route messages to their intended recipient without any one wallet knowing the details of the other. Encrypted messages can be sent to peers even if they are not online, and the Mediator will manage a queue for the offline party until they are able to connect and retrieve them.\nThink of a Mediator like a set of Post Office mailboxes. Each mailbox has a mailing address (a DID). Each mailbox can hold an stack of incoming mail Encrypted DIDComm V2 messages for its owner. Each mailbox also keeps a list of cryptographic Connections with whom its owner can send or receive mail with. In this way, Identus Mediators facilitate all types of important transactions, including routing both messages, Verifiable Credential issuance, and Credential Exchange.\nWhat’s important is that the Mediator, while messages are routed through it, is not a centralized actor. Mediators can not know the contents of any message, only what DIDs can talk to other DIDs and what encrypted messages they have yet to read.",
    "crumbs": [
      "Section IV - Deploy",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Mediator</span>"
    ]
  },
  {
    "objectID": "section4/mediator.html#overview",
    "href": "section4/mediator.html#overview",
    "title": "18  Mediator",
    "section": "",
    "text": "18.1.1 Why use a Mediator?\nWhy do we need a Mediator in the first place? If participants are Self-Sovereign, then why not connect an edge wallet directly to another edge wallet?\nSSI participants are connected through various types of devices and network conditions. The Cloud Agent, is expected to be online and available all the time, as it’s hosted in a remote server farm somewhere. However users who keep their wallets on mobile devices, or laptop computers, are only online sporadically, and can’t be expected to have a reliable connection to the Internet at all times. This is where Mediators earn their keep. If User A were to send a message to User B, who happens to be offline at the moment, the message could not be delivered, plus User A would also have to know sensitive data about how to contact User B. If User B changes devices, they would have to tell User A, and all other peer Connections. If User A instead, sends the message through the Mediator, it can be held securely and retrieved the next time User B connects to the Internet. Mediators provide reliability between Connections, without compromising privacy or security.",
    "crumbs": [
      "Section IV - Deploy",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Mediator</span>"
    ]
  },
  {
    "objectID": "section4/mediator.html#set-up-a-mediator",
    "href": "section4/mediator.html#set-up-a-mediator",
    "title": "18  Mediator",
    "section": "18.2 Set up a Mediator",
    "text": "18.2 Set up a Mediator\nWe will teach the reader how to\n\nInstall, configure, and Run your own Mediator\nHow to manage web sockets\nPerformance Tuning",
    "crumbs": [
      "Section IV - Deploy",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Mediator</span>"
    ]
  },
  {
    "objectID": "section4/maintenance.html",
    "href": "section4/maintenance.html",
    "title": "19  Maintenance",
    "section": "",
    "text": "Mastering Identus means maintaing your application once it’s launched.\nIn this chapter we will cover:\n\nObservability\n\nManage nodes / Memory\nPerformance Testing\nAnalytics with BlockTrust Analytics\n\nUpgrading Agents\n\nHow to minimize downtime\n\nHashicorp\n\nKey Management\nKey rotation",
    "crumbs": [
      "Section IV - Deploy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Maintenance</span>"
    ]
  },
  {
    "objectID": "section5/trust-registries.html",
    "href": "section5/trust-registries.html",
    "title": "20  Trust Registries",
    "section": "",
    "text": "Overview of the concept of a Trust Registry\n\nWhat role they play in SSI\nTrust Over IP Trust Registry Spec\nHighlight any real world examples if they exist by book completion",
    "crumbs": [
      "Section V - Addendum",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Trust Registries</span>"
    ]
  },
  {
    "objectID": "section5/continuing-your-journey.html",
    "href": "section5/continuing-your-journey.html",
    "title": "21  Continuing on Your Journey",
    "section": "",
    "text": "Information about becoming a Contributor to Identus\n\nHow to contribute to the source code or documentation\n\nInformation about how to get involved in the SSI community outside of Identus\nTrust over IP (ToIP)\nTrust Over IP (ToIP) comprises over 300 organizations from diverse industries collaborating to advance Decentralized Identity through ideas and software. According to ToIP, “We develop tools and specifications to help communities of any size use digital networks to build and strengthen trust between participants.”\nThe ToIP Stack, published in 2019, describes how the four layers (DIDs, DIDComm Protocol, Data Exchange Protocols, and Application Ecosystems) form a secure, scalable, and interoperable digital trust framework. Introduction to ToIP, Version 2.0, released in 2021, is an excellent resource for anyone catching up on the Digital Identity problem and solution. Membership options include free Contributor accounts and paid memberships, providing access to ToIP’s resources and Slack channels for collaboration.\nTo join Trust Over IP, you need to create a free Linux Foundation account and then complete your ToIP application here.\nAll members agree to open, non-competitive participation, so please have your legal team review all associated documents during the onboarding process.\nFor further details, refer to The ToIP Stack and Overview.\nDecentralized Identity Foundation (DIF)",
    "crumbs": [
      "Section V - Addendum",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Continuing on Your Journey</span>"
    ]
  },
  {
    "objectID": "errata.html",
    "href": "errata.html",
    "title": "22  Errata",
    "section": "",
    "text": "Errata goes here\nWe will list any bugs that may have been “printed” in certain editions of the book.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Errata</span>"
    ]
  },
  {
    "objectID": "glossary.html",
    "href": "glossary.html",
    "title": "Glossary",
    "section": "",
    "text": "Glossary or Index here\nThis will reference key concepts and Identus terms and where they are mentioned in the book, allowing someone to look up a term and know what section it is referenced in.\nTODO: First draft will just lay down the glossary terms, we want to add detailed descriptions later.\n\nVDR\n\nVerifiable Data Registry",
    "crumbs": [
      "Appendices",
      "Glossary"
    ]
  }
]